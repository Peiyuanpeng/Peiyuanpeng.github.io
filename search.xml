<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>请您认真阅读并扫码添加汪医生好友</title>
      <link href="/2023/08/24/%E8%AF%B7%E6%82%A8%E8%AE%A4%E7%9C%9F%E9%98%85%E8%AF%BB%E5%B9%B6%E6%89%AB%E7%A0%81%E5%8A%A0%E6%88%91%E5%A5%BD%E5%8F%8B/"/>
      <url>/2023/08/24/%E8%AF%B7%E6%82%A8%E8%AE%A4%E7%9C%9F%E9%98%85%E8%AF%BB%E5%B9%B6%E6%89%AB%E7%A0%81%E5%8A%A0%E6%88%91%E5%A5%BD%E5%8F%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="您好！本账号用于肥胖与减重门诊的随访信息采集，便于医生提醒您完成用药后随访和问卷。出于安全性考虑，本账号不针对任何临床问题进行回复，请您谅解。若您有任何用药相关问题，请前来减重门诊就诊。（此条消息为自动发送，无需回复）"><a href="#您好！本账号用于肥胖与减重门诊的随访信息采集，便于医生提醒您完成用药后随访和问卷。出于安全性考虑，本账号不针对任何临床问题进行回复，请您谅解。若您有任何用药相关问题，请前来减重门诊就诊。（此条消息为自动发送，无需回复）" class="headerlink" title="您好！本账号用于肥胖与减重门诊的随访信息采集，便于医生提醒您完成用药后随访和问卷。出于安全性考虑，本账号不针对任何临床问题进行回复，请您谅解。若您有任何用药相关问题，请前来减重门诊就诊。（此条消息为自动发送，无需回复）"></a>您好！本账号用于肥胖与减重门诊的随访信息采集，便于医生提醒您完成用药后随访和问卷。出于安全性考虑，本账号不针对任何临床问题进行回复，请您谅解。若您有任何用药相关问题，请前来减重门诊就诊。（此条消息为自动发送，无需回复）</h2><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202308242310981.jpg" alt="7d3a2abddb5205b4daf0d46dd1b5b10"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NR小区搜索及MIB和SIB1恢复</title>
      <link href="/2023/07/18/NR%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E5%8F%8AMIB%E5%92%8CSIB1%E6%81%A2%E5%A4%8D/"/>
      <url>/2023/07/18/NR%E5%B0%8F%E5%8C%BA%E6%90%9C%E7%B4%A2%E5%8F%8AMIB%E5%92%8CSIB1%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="NR小区搜索及MIB和SIB1恢复"><a href="#NR小区搜索及MIB和SIB1恢复" class="headerlink" title="NR小区搜索及MIB和SIB1恢复"></a>NR小区搜索及MIB和SIB1恢复</h2><ul><li><em>本示例演示了如何使用5G Toolbox™对实时gNodeB信号进行同步、解调和解码</em></li><li><em>该示例解码MIB和第一个系统信息块（SIB1）</em></li><li><em>解码MIB和SIB1需要一个全面的接收机，能够解调和解码大部分下行链路信道和信号。</em></li></ul><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在用户设备（UE）与网络通信之前，它必须执行小区搜索和选择程序，并获得初始系统信息。该过程的第一步是获取帧同步、找出小区标识以及解码MIB和SIB1。本示例展示了如何使用5G工具箱执行这些步骤。</p><p>您可以使用本示例捕获的I/Q采样波形，也可以使用nrWaveformGenerator生成包含同步信号（SS）突发和SIB1的本地波形。对于本地生成的波形，示例执行以下步骤：</p><ul><li><p><strong>波形生成：</strong></p><ul><li>使用5G工具箱中的下行链路波形发生器配置和生成同步信号突发，其中包含<strong>MIB、CORESET 0、PDCCH和携带SIB1的PDSCH。</strong></li><li>发射机可以提高一个SS块的信噪比，但不进行波束成形。有关SSB波束成形的更多信息，请参阅NR SSB Beam Sweeping。</li></ul></li><li><p><strong>AWGN：</strong>对波形施加加性白高斯噪声（AWGN）</p></li><li><p><strong>接收器：</strong> 对接收波形进行各种同步和解调处理，以确定系统帧号、小区标识和 SSB，并解码 MIB。这些都是对 PDCCH 中的下行链路控制信息（DCI）进行盲解码所需的信息。接收器利用 DCI 配置 PDSCH 解调器，解码 DL-SCH 并最终恢复 SIB1。</p></li></ul><p><strong>这些图显示了接收器内部的处理步骤：</strong></p><hr><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201514196.png" alt="img"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307191129578.png" alt="img"></p><hr><h3 id="接收器配置"><a href="#接收器配置" class="headerlink" title="接收器配置"></a>接收器配置</h3><p><strong>主要代码：</strong></p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 生成包含 SS burst 和 SIB1 的波形</span></span><br><span class="line">  <span class="comment">% 配置单元格标识</span></span><br><span class="line">  config = struct();</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>struct数组：</strong></p><p><em>结构体数组</em>是使用名为<em>字段</em>的数据容器将相关数据组合在一起的数据类型。每个字段都可以包含任意类型的数据。可以使用 structName.fieldName格式的圆点表示法来访问字段中的数据。</p><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">config.NCellID = <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 配置 SS 突发</span></span><br><span class="line">config.BlockPattern = <span class="string">'Case B'</span>;         <span class="comment">% FR1: 'Case A','Case B','Case C'. FR2: 'Case D','Case E'</span></span><br><span class="line">config.TransmittedBlocks = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">8</span>);   <span class="comment">% 传输的 SS 数据块的位图</span></span><br><span class="line">config.SubcarrierSpacingCommon = <span class="number">15</span>;    <span class="comment">% SIB1 子载波间隔（千赫）（FR1 为 15 或 30，FR2 为 60 或 120</span></span><br><span class="line">config.EnableSIB1 = <span class="number">1</span>;                  <span class="comment">% 设置为 0 时禁用 SIB1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置 NR 频段所需的最小信道带宽，以便在 FR1 中配置 CORESET 0（见 TS 38.101-1 表 5.3.5-1）。</span></span><br><span class="line"><span class="comment">% 在 FR1 中配置 CORESET 0（见 TS 38.101-1 表 5.3.5-1）</span></span><br><span class="line">config.MinChannelBW = <span class="number">5</span>; <span class="comment">% 5, 10, 40 MHz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过提高功率（从而提高信噪比）引入波束成形增益。</span></span><br><span class="line"><span class="comment">% 提高一个 SSB 及相关 SIB1 PDCCH 和 PDSCH 的功率（从而提高 SNR）</span></span><br><span class="line">boost = <span class="number">6</span>; <span class="comment">% SNR boost in dB</span></span><br><span class="line">config.Power = <span class="built_in">zeros</span>(<span class="built_in">size</span>(config.TransmittedBlocks));</span><br><span class="line">config.Power(<span class="number">1</span>) = boost; <span class="comment">% boost the first SSB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 配置并生成包含 SS 脉冲串和 SIB1 的波形</span></span><br><span class="line">wavegenConfig = hSIB1WaveformConfiguration(config);</span><br><span class="line">[txWaveform,waveInfo] = nrWaveformGenerator(wavegenConfig);</span><br><span class="line">txOfdmInfo = waveInfo.ResourceGrids(<span class="number">1</span>).Info;</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>hSIB1WaveformConfiguration：</strong></p><ul><li><p>WAVEGENCONFIG = hSIB1WaveformConfiguration(CONFIG)会创建一个nrDLCarrierConfig 配置对象</p></li><li><p>用于生成携带主信息块的 SS 突发和携带第一系统的<strong>控制和数据通道</strong></p></li><li><p><strong>控制和数据通道</strong>携带第一个系统信息块 (SIB1)的控制和数据通道</p></li></ul><hr><p><strong>nrDLCarrierConfig：</strong></p><p><strong>解释：</strong>nrDLCarrierConfig 对象用于设置单分量载波 5G 下行链路波形的参数。调用 nrWaveformGenerator 函数时，使用该对象配置 5G 下行链路波形生成。</p><p><strong>该对象定义了下行链路波形的这些方面：</strong></p><ul><li><p>Frequency range<strong>（频率范围）</strong> </p></li><li><p>Channel bandwidth<strong>（信道带宽）</strong></p></li><li><p>Cell identity<strong>（小区标识）</strong></p></li><li><p>Waveform duration<strong>（波形持续时间）</strong></p></li><li><p>Subcarrier spacing (SCS) carriers<strong>（子载波间隔【SCS】载波）</strong></p></li><li><p>Bandwidth parts (BWPs)<strong>（带宽部件【BWP】）</strong></p></li><li><p>Synchronization signal (SS) burst<strong>（同步信号（SS）突发）</strong></p></li><li><p>Control resource sets (CORESETs)<strong>（控制资源集）（CORESET）</strong></p></li><li><p>Search spaces<strong>（搜索空间）</strong></p></li><li><p>Physical downlink control channel (PDCCH) and PDCCH demodulation reference signal (DM-RS) <strong>（物理下行链路控制信道 (PDCCH) 和 PDCCH 解调参考信号 (DM-RS)）</strong></p></li><li><p>Physical downlink shared channel (PDSCH), PDSCH DM-RS, and PDSCH phase-tracking reference signal (PT-RS) <strong>（物理下行链路共享信道 (PDSCH)、PDSCH DM-RS 和 PDSCH 相位跟踪参考信号 (PT-RS)）</strong></p></li><li><p>Channel state information reference signal (CSI-RS) <strong>（信道状态信息参考信号 (CSI-RS)）</strong></p></li></ul><hr><p><strong>nrWaveformGenerator：</strong></p><p><strong>解释：</strong>[wave,info] = nrWaveformGenerator(cfg) 为指定的配置 cfg 生成 5G NR 波形波。输入 cfg 指定了单个或多个子载波间隔（SCS）载波和带宽部分（BWP）的下行或上行配置参数。</p><ul><li>如果 cfg 是 nrDLCarrierConfig 对象，配置还会指定同步信号 (SS) 突发、控制资源集 (CORESET)、搜索空间、物理下行链路控制信道 (PDCCH) 和相关解调参考信号 (DM-RS)、物理下行链路共享信道 (PDSCH) 和相关 DM-RS 和相位跟踪参考信号 (PT-RS)，以及信道状态信息参考信号 (CSI-RS)。</li><li>该函数还会返回一个结构信息，其中包含有关资源网格和波形资源的信息。</li></ul><p>函数中txWaveform为波形信息，可以在matlab中绘制出函数图像，由于txWaveform是复数信息，故绘制出的仅为时间关于幅度的函数。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span> : <span class="number">1</span> : <span class="built_in">size</span>(txWaveform)</span><br><span class="line"><span class="built_in">plot</span>(x,txWaveform)</span><br><span class="line">xlabel(<span class="string">'time'</span>)</span><br><span class="line">ylabel(<span class="string">'txWaveform'</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>不过绘制的时候系统自动忽略了一些参数：</strong><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201424203.png" alt="image-20230720142409175"></p><p><strong>结果图如下：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201424731.png" alt="image-20230720142433705"></p><p><strong>waveInfo：</strong>就是返回的结构信息</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201426721.png" alt="image-20230720142611699"></p><p>代码中的<strong>waveInfo.ResourceGrids(1).Info</strong>信息也可以在控制台查看：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201427244.png" alt="image-20230720142714216"></p><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 在波形中添加白高斯噪声。</span></span><br><span class="line"><span class="comment">% 请注意，信噪比仅适用于增强的 SSB / SIB1</span></span><br><span class="line">rng(<span class="string">'default'</span>); <span class="comment">% 重置随机数生成器</span></span><br><span class="line">SNRdB = <span class="number">20</span>; <span class="comment">% AWGN 的信噪比</span></span><br><span class="line">rxWaveform = awgn(txWaveform,SNRdB-boost,<span class="number">-10</span>*<span class="built_in">log10</span>(double(txOfdmInfo.Nfft)));</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>awgn：</strong></p><ul><li><p>Y = awgn(X,snr,signalpower) 接受以 dBW 为单位的输入信号功率值。</p></li><li><p>要在添加噪声前测量 X 的功率，请将 signalpower 指定为 “实测”。</p></li><li><p>如果输入信号功率因衰减而随时间变化，且信道相干时间大于输入持续时间，那么在循环中重复调用 awgn 函数时，”测量 “选项不会生成所需的平均信噪比。</p></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">% 配置接收器</span></span><br><span class="line">    <span class="comment">% 采样率</span></span><br><span class="line">    sampleRate = txOfdmInfo.SampleRate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 符号相位补偿频率（赫兹）。</span></span><br><span class="line">    <span class="comment">% 函数nrWaveformGenerator 不对生成的波形进行符号相位补偿。</span></span><br><span class="line">    <span class="comment">% 生成波形。</span></span><br><span class="line">    fPhaseComp = <span class="number">0</span>; <span class="comment">%载波中心频率（赫兹）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% 最小通道带宽（兆赫）</span></span><br><span class="line">    minChannelBW = config.MinChannelBW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 在接收器上配置必要的突发参数</span></span><br><span class="line">    refBurst.BlockPattern = config.BlockPattern;</span><br><span class="line">    <span class="comment">% n = numel(A) 返回数组 A 中的元素数目 n 等同于 prod(size(A))。</span></span><br><span class="line">    refBurst.L_max = <span class="built_in">numel</span>(config.TransmittedBlocks); </span><br><span class="line"></span><br><span class="line"><span class="comment">% 从配置的突发和接收机参数中获取 OFDM 信息</span></span><br><span class="line">nrbSSB = <span class="number">20</span>;</span><br><span class="line">scsSSB = hSSBurstSubcarrierSpacing(refBurst.BlockPattern); <span class="comment">% 这是一个获取子载波间隔的函数</span></span><br><span class="line">rxOfdmInfo = nrOFDMInfo(nrbSSB,scsSSB,<span class="string">'SampleRate'</span>,sampleRate);</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrOFDMInfo：</strong></p><ul><li><p>info = nrOFDMInfo(载波) 为指定的载波配置参数提供与正交频分复用（OFDM）调制相关的尺寸信息。</p></li><li><p>info = nrOFDMInfo(nrb,scs) 为指定的资源块数量 nrb 和子载波间隔 scs 提供 OFDM 信息。</p></li><li><p>info = nrOFDMInfo(,名称,值) 除前面任何语法中的输入参数外，使用一个或多个名称-值对参数指定选项。</p></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 显示接收波形的频谱图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">nfft = rxOfdmInfo.Nfft;</span><br><span class="line">spectrogram(rxWaveform(:,<span class="number">1</span>),<span class="built_in">ones</span>(nfft,<span class="number">1</span>),<span class="number">0</span>,nfft,<span class="string">'centered'</span>,sampleRate,<span class="string">'yaxis'</span>,<span class="string">'MinThreshold'</span>,<span class="number">-130</span>);</span><br><span class="line">title(<span class="string">'Spectrogram of the Received Waveform'</span>)</span><br></pre></td></tr></tbody></table></figure><hr><p>整段代码运行结果图：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201458525.png" alt="image-20230720145839483"></p><hr><h3 id="PSS-搜索和频率偏移校正"><a href="#PSS-搜索和频率偏移校正" class="headerlink" title="PSS 搜索和频率偏移校正"></a>PSS 搜索和频率偏移校正</h3><p>接收器按照以下步骤进行 PSS 搜索和粗频率偏移估算：</p><ul><li><p>用候选频率偏移对接收到的波形进行移频。候选偏移间隔为半个子载波。使用 searchBW 控制频率偏移搜索带宽。</p></li><li><p>将频率偏移后的接收波形与三个可能的 PSS 序列（NID2）逐一<strong>相关</strong>，并提取最强的相关峰值。<strong>参考 PSS 序列的频率居中</strong>。因此，最强相关峰值提供了相对于载波中心频率的<strong>粗频率偏移量</strong>。</p></li><li><p>该峰值还表明在接收波形中检测到了三个 PSS（NID2）中的哪一个，以及最佳信道条件的时间瞬间。</p></li><li><p>通过将 SSB 中每个 OFDM 符号的<strong>循环前缀</strong>与 OFDM 符号的相应有用部分相关联，估算出低于半个子载波的频率偏移。这种相关性的相位与波形中的频率偏移成正比。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>(<span class="string">' -- Frequency correction and timing estimation --'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 以千赫为单位指定频率偏移搜索带宽</span></span><br><span class="line">searchBW = <span class="number">6</span>*scsSSB;</span><br><span class="line"><span class="comment">% SS 脉冲串波形的频率偏移校正</span></span><br><span class="line">[rxWaveform,freqOffset,NID2] = hSSBurstFrequencyCorrect(rxWaveform,refBurst.BlockPattern,sampleRate,searchBW);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">' Frequency offset: '</span> num2str(freqOffset,<span class="string">'%.0f'</span>) <span class="string">' Hz'</span>])</span><br></pre></td></tr></tbody></table></figure><p><strong>结果图：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201512942.png" alt="image-20230720151253912"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201534569.png" alt="image-20230720153430549"></p><hr><h3 id="时间同步和-OFDM-解调"><a href="#时间同步和-OFDM-解调" class="headerlink" title="时间同步和 OFDM 解调"></a>时间同步和 OFDM 解调</h3><ul><li><p>接收机利用频率搜索过程中检测到的参考 PSS 序列，估算出最强 SS 块的定时偏移。</p></li><li><p>经过频率偏移校正后，接收器可以认为参考 PSS 和接收波形的中心频率是一致的。</p></li><li><p>最后，接收器 OFDM 对同步波形进行解调，提取 SS 块。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 利用检测到的 PSS 创建用于时序估计的参考网格。</span></span><br><span class="line"><span class="comment">% PSS放在参考网格的第二个 OFDM 符号中，以避免第一个 OFDM 符号的特殊 CP 长度。</span></span><br><span class="line">refGrid = <span class="built_in">zeros</span>([nrbSSB*<span class="number">12</span> <span class="number">2</span>]);</span><br><span class="line">refGrid(nrPSSIndices,<span class="number">2</span>) = nrPSS(NID2); <span class="comment">% 正确 CP 长度的第二个 OFDM 符号</span></span><br></pre></td></tr></tbody></table></figure><hr><p>**nrPSS:**sym = nrPSS(ncellid) 返回物理层小区标识号 ncellid 的主同步信号（PSS）符号。该函数实现了 TS 38.211 第 7.4.2.2 节 [1]。</p><p>nrPSSIndices这个变量是PSS对应子载波的序号数，从下图中可以看出这一点。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201647888.png" alt="image-20230720164729852"></p><p>这张图的子载波数是从0开始标记序号的，在matlab中是从1开始标记序号的，因此是从57 - 183。为了更好的观看这里将列向量转换成行向量进行观察。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201649330.png" alt="image-20230720164904289"></p><p>最终变量refGrid中也仅有第二列的这些序号位置有值，如下图所示：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201650425.png" alt="image-20230720165005400"></p><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 时序估计。这是在检测到 SSB 之前的 OFDM 符号的时序偏移。</span></span><br><span class="line"><span class="comment">% 由于参考网格的内容而导致的检测到的 SSB 的时间偏移。</span></span><br><span class="line">nSlot = <span class="number">0</span>;</span><br><span class="line">timingOffset = nrTimingEstimate(rxWaveform,nrbSSB,scsSSB,nSlot,refGrid,<span class="string">'SampleRate'</span>,sampleRate);</span><br></pre></td></tr></tbody></table></figure><hr><p>[offset,mag] = nrTimingEstimate(carrier,waveform,refGrid)：</p><ul><li>通过将输入波形与参考波形进行交叉相关来执行实用的定时估计。</li><li>函数通过使用正交频分复用（OFDM）调制参考资源网格 refGrid 来获取参考波形。</li><li>函数返回输入波形中每个接收天线的估计时序偏移（offset）和估计脉冲响应幅度（mag）。</li></ul><p>[offset,mag] = nrTimingEstimate(waveform,nrb,scs,initialNSlot,refGrid)： </p><ul><li>通过调制参考资源网格 refGrid 并使用 OFDM 调制，以子载波间隔 scs 和初始时隙数 initialNSlot 跨 nrb 资源块，获得参考波形。</li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 同步、OFDM 解调和提取最强 SS 块</span></span><br><span class="line">rxGrid = nrOFDMDemodulate(rxWaveform(<span class="number">1</span>+timingOffset:<span class="keyword">end</span>,:),nrbSSB,scsSSB,nSlot,<span class="string">'SampleRate'</span>,sampleRate);</span><br><span class="line">rxGrid = rxGrid(:,<span class="number">2</span>:<span class="number">5</span>,:);</span><br></pre></td></tr></tbody></table></figure><hr><p>grid = nrOFDMDemodulate（carrier,waveform）通过解调波形（OFDM 调制波形）来恢复载波配置参数 carrier 的载波资源阵列。</p><p>grid = nrOFDMDemodulate(waveform,nrb,scs,initialNSlot) 为 nrb、指定的资源块数、子载波间隔 scs 和初始时隙数 initialNSlot 解调波形。</p><p><strong>rxGrid最开始为一个240 × 557的向量：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201750373.png" alt="image-20230720175034350"></p><p><strong>代码中仅获取了第2到5列：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201751828.png" alt="image-20230720175134810"></p><ul><li>240是一个OFDM的子载波个数</li><li>取4列是因为一个SSB在时域上占据了4个OFDM符号</li><li>为什么取2 - 5l列还有待思考</li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 以样本为单位显示定时偏移。</span></span><br><span class="line"><span class="comment">% 由于符号长度是以 FFT 样本测量的，因此要根据接收机的采样率。</span></span><br><span class="line">srRatio = sampleRate/(scsSSB*<span class="number">1e3</span>*rxOfdmInfo.Nfft);</span><br><span class="line">firstSymbolLength = rxOfdmInfo.SymbolLengths(<span class="number">1</span>)*srRatio;</span><br><span class="line">str = sprintf(<span class="string">' Time offset to synchronization block: %%.0f samples (%%.%.0ff ms) \n'</span>,<span class="built_in">floor</span>(<span class="built_in">log10</span>(sampleRate))<span class="number">-3</span>);</span><br><span class="line">fprintf(str,timingOffset+firstSymbolLength,(timingOffset+firstSymbolLength)/sampleRate*<span class="number">1e3</span>);</span><br></pre></td></tr></tbody></table></figure><p>最后的目的是为了测量定时偏移：</p><ul><li>sampleRate是采样率，通过上述公式可以计算出srRatio，srRatio是一个OFDM符号在时域上是采样时间的几倍，换句话来讲就是一个OFDM符号需要的采样次数。</li><li>firstSymbolLength是通过OFDM基本信息以及srRatio参数计算得出的第一个OFDM符号的点数。</li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201757503.png" alt="image-20230720175718479"></p><ul><li>总共的点数就是偏移量与第一个OFDM符号点数相加，这里是1644 + 556 = 2200.</li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201758602.png" alt="image-20230720175847581"></p><ul><li>采样一次需要1/sampleRate的时间，故总共产生 (timingOffset+firstSymbolLength)/sampleRate 时间的偏移，最后再乘以1e3换算成毫秒单位得到我们最终的结果</li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307201759240.png" alt="image-20230720175922220"></p><hr><h3 id="SSS-搜索"><a href="#SSS-搜索" class="headerlink" title="SSS 搜索"></a>SSS 搜索</h3><ul><li><p>接收器从接收到的网格中提取与 SSS 相关的资源元素，并将其与本地生成的每个可能的 SSS 序列相关联。</p></li><li><p>最强 PSS 序列和 SSS 序列的索引组合给出物理层小区标识，这是 PBCH DM-RS 和 PBCH 处理所必需的。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 从 SS/PBCH 数据块中提取接收到的 SSS 符号</span></span><br><span class="line">sssIndices = nrSSSIndices;</span><br><span class="line">sssRx = nrExtractResources(sssIndices,rxGrid);</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>同理，可以在matlab控制台打印出sssIndices的具体数值，如下图所示：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307211428583.png" alt="image-20230721142833531"></p><p>通过分析可知，sss子载波序列的序号是按顺序累加的，时域上第一个OFDM符号的序号是1。</p><hr><p><strong>nrExtractResources：</strong></p><ul><li><p>re = nrExtractResources(ind,grid) 使用资源元素索引 ind 从资源数组 grid 中返回资源元素。即使 grid 的维数与索引 ind 的维数不同，函数也能提取资源元素。在此语法中，指定的索引以 1 为基础，使用线性索引形式。</p></li><li><p>通常，特定信道或信号函数会生成资源元素索引，以便将信道或信号符号映射到资源网格。这些索引针对的是 M-by-N-byP 数组中的资源元素。M 是子载波数，N 是 OFDM 符号数，P 是天线端口数。</p></li></ul><p>这个函数就是提取响应索引位置的值，在上一个步骤中，我们已经获取了240 × 4，名称为rxGrid的二维矩阵，根据SSS的子载波的序号数可以提取出相应位置的SSS信号的数据，在代码中即为sssRx。</p><p>通过Excel可以直观地看清楚这部分数据的位置和数值：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307211457185.png" alt="image-20230721145729121"></p><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 将接收到的 SSS 符号与每个可能的 SSS 序列相关联</span></span><br><span class="line">sssEst = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">336</span>);</span><br><span class="line"><span class="keyword">for</span> NID1 = <span class="number">0</span>:<span class="number">335</span></span><br><span class="line"></span><br><span class="line">    ncellid = (<span class="number">3</span>*NID1) + NID2;</span><br><span class="line">    sssRef = nrSSS(ncellid);</span><br><span class="line">    sssEst(NID1+<span class="number">1</span>) = sum(<span class="built_in">abs</span>(<span class="built_in">mean</span>(sssRx .* <span class="built_in">conj</span>(sssRef),<span class="number">1</span>)).^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrSSS：</strong></p><p>sym = nrSSS(ncellid) 返回物理层小区标识号 ncellid 的二次同步信号（SSS）符号。该函数实现了 TS 38.211 第 7.4.2.3 节 [1]。</p><ul><li><p>这个函数的目的就是根据真实的小区id号，获取相应的sss序列。</p></li><li><p>最后再通过信号与共轭信号相乘 –&gt; 求均值（相关运算）–&gt; 求模值，并将信息存储到sssEst这个矩阵当中</p></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 绘制 SSS 关联图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(<span class="number">0</span>:<span class="number">335</span>,sssEst,<span class="string">'o'</span>);</span><br><span class="line">title(<span class="string">'SSS Correlations (Frequency Domain)'</span>);</span><br><span class="line">xlabel(<span class="string">'$N_{ID}^{(1)}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">ylabel(<span class="string">'Magnitude'</span>);</span><br><span class="line">axis([<span class="number">-1</span> <span class="number">336</span> <span class="number">0</span> <span class="built_in">max</span>(sssEst)*<span class="number">1.1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 通过找到最强相关性来确定 NID1</span></span><br><span class="line">NID1 = <span class="built_in">find</span>(sssEst==<span class="built_in">max</span>(sssEst)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制选定的 NID1</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(NID1,<span class="built_in">max</span>(sssEst),<span class="string">'kx'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'MarkerSize'</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">legend</span>([<span class="string">"correlations"</span> <span class="string">"$N_{ID}^{(1)}$ = "</span> + num2str(NID1)],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 根据估计的 NID1 和 NID2 形成整体小区特征</span></span><br><span class="line">ncellid = (<span class="number">3</span>*NID1) + NID2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">' Cell identity: '</span> num2str(ncellid)])</span><br></pre></td></tr></tbody></table></figure><p><strong>运行结果：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307211941543.png" alt="image-20230721194158508"></p><hr><h3 id="PBCH-DM-RS-搜索"><a href="#PBCH-DM-RS-搜索" class="headerlink" title="PBCH DM-RS 搜索"></a>PBCH DM-RS 搜索</h3><ul><li><p>在类似于 SSS 搜索的过程中，接收器构建每个可能的 PBCH DM-RS 序列，并进行信道和噪声估计。</p></li><li><p>信噪比最佳的 PBCH DM-RS 的索引决定了 PBCH 加扰初始化所需的 SS/PBCH 块索引的 LSBs。</p></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 计算 PBCH DM-RS 指数</span></span><br><span class="line">dmrsIndices = nrPBCHDMRSIndices(ncellid);</span><br></pre></td></tr></tbody></table></figure><ul><li>nd = nrPBCHDMRSIndices(ncellid) 返回物理广播信道（PBCH）解调参考信号（DM-RS）的资源要素索引。</li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307211712559.png" alt="image-20230721171216533"></p><p>从图中可以看出索引号间隔为4。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 使用 DM-RS 符号对每个可能的 DM-RS 进行信道估计序列，并估计信噪比</span></span><br><span class="line">dmrsEst = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> ibar_SSB = <span class="number">0</span>:<span class="number">7</span></span><br><span class="line">    refGrid = <span class="built_in">zeros</span>([<span class="number">240</span> <span class="number">4</span>]);</span><br><span class="line">    refGrid(dmrsIndices) = nrPBCHDMRS(ncellid,ibar_SSB);<span class="comment">% nrPBCHDMRS生成标准中定义的所有DM-RS信号</span></span><br><span class="line">    [hest,nest] = nrPBCHDMRS(rxGrid,refGrid,<span class="string">'AveragingWindow'</span>,[<span class="number">0</span> <span class="number">1</span>]);</span><br><span class="line">    dmrsEst(ibar_SSB+<span class="number">1</span>) = <span class="number">10</span>*<span class="built_in">log10</span>(<span class="built_in">mean</span>(<span class="built_in">abs</span>(hest(:).^<span class="number">2</span>)) / nest);<span class="comment">% 做相关检测的过程</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrPBCHDMRS:</strong></p><ul><li>sym = nrPBCHDMRS(ncellid,ibar_SSB) 返回由 ncellid 标识的物理层小区的物理广播信道（PBCH）解调参考信号（DM-RS）符号。</li><li>ibar_SSB 输入指定 DM-RS 加扰初始化的时间相关部分。该函数实现了 TS 38.211 第 7.4.1.4.1 节 [1]。</li></ul><p><strong>refGrid变量如下图所示：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307211722861.png" alt="image-20230721172246830"></p><p><strong>nrPBCHDMRS:</strong></p><p>[h,nVar,info] = nrChannelEstimate(rxGrid,refInd,refSym) 通过在 refInd 位置使用包含参考符号 refSym 的参考资源网格，对接收到的资源网格 rxGrid 执行实用的信道估计。函数返回<strong>信道估计值 h、噪声方差估计值 nVar 和附加信息 info</strong>。</p><ul><li>[h,nVar,info]=nrChannelEstimate(____,Name,Value)除了使用前面任何一种语法中的输入参数外，还使用一个或多个名-值对参数来指定选项。</li></ul><p><strong>AveragingWindow变量：</strong>插值前平均窗口，以逗号分隔的 “AveragingWindow “和 1×2 的奇数非负整数[F T]数组。</p><ul><li><p>数组元素 F 和 T 分别指定频域和时域中相邻参考符号的数量，函数在插值前对这些符号进行平均。</p></li><li><p>如果 F 或 T 为零，函数将根据基于噪声方差估计值 nVar 的估计信噪比 (SNR) 确定平均值。</p></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 绘制 PBCH DM-RS 信噪比</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">stem(<span class="number">0</span>:<span class="number">7</span>,dmrsEst,<span class="string">'o'</span>);</span><br><span class="line">title(<span class="string">'PBCH DM-RS SNR Estimates'</span>);</span><br><span class="line">xlabel(<span class="string">'$\overline{i}_{SSB}$'</span>,<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br><span class="line">xticks(<span class="number">0</span>:<span class="number">7</span>);</span><br><span class="line">ylabel(<span class="string">'Estimated SNR (dB)'</span>);</span><br><span class="line">axis([<span class="number">-1</span> <span class="number">8</span> <span class="built_in">min</span>(dmrsEst)<span class="number">-1</span> <span class="built_in">max</span>(dmrsEst)+<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 记录信噪比最高的 ibar_SSB</span></span><br><span class="line">ibar_SSB = <span class="built_in">find</span>(dmrsEst==<span class="built_in">max</span>(dmrsEst)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 绘制选定的 ibar_SSB</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(ibar_SSB,<span class="built_in">max</span>(dmrsEst),<span class="string">'kx'</span>,<span class="string">'LineWidth'</span>,<span class="number">2</span>,<span class="string">'MarkerSize'</span>,<span class="number">8</span>);</span><br><span class="line"><span class="built_in">legend</span>([<span class="string">"SNRs"</span> <span class="string">"$\overline{i}_{SSB}$ = "</span> + num2str(ibar_SSB)],<span class="string">'Interpreter'</span>,<span class="string">'latex'</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>运行结果：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307211942236.png" alt="image-20230721194221202"></p><hr><h3 id="使用-PBCH-DM-RS-和-SSS-进行信道估计"><a href="#使用-PBCH-DM-RS-和-SSS-进行信道估计" class="headerlink" title="使用 PBCH DM-RS 和 SSS 进行信道估计"></a>使用 PBCH DM-RS 和 SSS 进行信道估计</h3><ul><li><p>接收机利用前几步检测到的 SSS 和 PBCH DM-RS 估计整个 SS/PBCH 块的信道。</p></li><li><p>此外，还要对 PBCH DM-RS / SSS 的加性噪声进行估计。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">refGrid = <span class="built_in">zeros</span>([nrbSSB*<span class="number">12</span> <span class="number">4</span>]);</span><br><span class="line">refGrid(dmrsIndices) = nrPBCHDMRS(ncellid,ibar_SSB);</span><br><span class="line">refGrid(sssIndices) = nrSSS(ncellid);</span><br><span class="line">[hest,nest,hestInfo] = nrChannelEstimate(rxGrid,refGrid,<span class="string">'AveragingWindow'</span>,[<span class="number">0</span> <span class="number">1</span>]);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="PBCH-解调"><a href="#PBCH-解调" class="headerlink" title="PBCH 解调"></a>PBCH 解调</h3><ul><li><p>接收器利用小区标识确定并从接收到的网格中提取与 PBCH 相关的资源元素。</p></li><li><p>此外，接收器利用信道和噪声估计值执行 <strong>MMSE 最小均方误差（Minimum Mean Square Error）均衡</strong>。</p></li><li><p>然后对均衡后的 PBCH 符号进行解调和解扰，给出编码 BCH 块的比特估计值。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disp</span>(<span class="string">' -- PBCH demodulation and BCH decoding -- '</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 从 SS/PBCH 块中提取接收到的 PBCH 符号</span></span><br><span class="line">[pbchIndices,pbchIndicesInfo] = nrPBCHIndices(ncellid);</span><br><span class="line">pbchRx = nrExtractResources(pbchIndices,rxGrid);</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrPBCHIndices：</strong></p><ul><li><p>[ind,info] = nrPBCHIndices(ncellid) 返回物理广播信道（PBCH）的资源要素索引 ind 和相关索引信息 info。</p></li><li><p>该函数实现了 TS 38.211 第 7.4.3.1 节 [1]。</p></li><li><p>相应的物理层小区标识号为 ncellid。</p></li><li><p>返回的索引采用线性索引形式，以 1 为基础。</p></li><li><p>这种索引形式可直接索引与同步信号/物理广播信道（SS/PBCH）块相对应的 240×4 矩阵的元素。</p></li><li><p>索引的顺序表示 PBCH 调制符号的映射方式。</p></li></ul><p>其中pbchIndicesInfo参数中含有两个变量G和Gd，如下图所示：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307221546092.png" alt="image-20230722154634063"></p><p><strong>根据官方文档的解释（我也没太看懂）：</strong></p><table><thead><tr><th>Parameter Field</th><th>Value</th><th>Description</th></tr></thead><tbody><tr><td>G</td><td>864</td><td>编码和速率匹配的 PBCH 数据比特数。</td></tr><tr><td>Gd</td><td>432</td><td>编码和速率匹配的 PBCH 数据符号数。Gd 等于 PBCH 索引的行数。</td></tr></tbody></table><p><strong>nrExtractResources：</strong></p><p>本函数在上文中已经解释过，最终可以获取相应变量pbchRx。</p><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 根据 TS 38.211 第 7.3.3.1 节为 PBCH 加扰配置 "v"</span></span><br><span class="line"><span class="comment">% 在 L_max=4 时，"v "也是 SS/PBCH 块索引的 2 个 LSB；在 L_max=8 或 64 时，"v "也是 SS/PBCH 块索引的 3 个 LSB。</span></span><br><span class="line"><span class="keyword">if</span> refBurst.L_max == <span class="number">4</span></span><br><span class="line">    v = <span class="built_in">mod</span>(ibar_SSB,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    v = ibar_SSB;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ssbIndex = v;</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>这里要mod4的原因我认为可以参考下图：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307221303784.jpeg"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307222233649.png" alt="image-20230722223300601"></p><p>实际上是为了获取时间索引，对于L = 4来讲，根据公式可以知道要进行mod运算（我猜的）。</p><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% PBCH 均衡和 CSI 计算</span></span><br><span class="line">pbchHest = nrExtractResources(pbchIndices,hest);</span><br><span class="line">[pbchEq,csi] = nrEqualizeMMSE(pbchRx,pbchHest,nest);</span><br><span class="line">Qm = pbchIndicesInfo./ pbchIndicesInfo.Gd;</span><br><span class="line">csi = <span class="built_in">repmat</span>(csi.',Qm,<span class="number">1</span>);</span><br><span class="line">csi = <span class="built_in">reshape</span>(csi,[],<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrExtractResources:</strong>[怕忘记，再次解释一遍]</p><ul><li><p>re = nrExtractResources(ind,grid) 使用资源元素索引 ind 从资源数组 grid 中返回资源元素。即使 grid 的维数与索引 ind 的维数不同，函数也能提取资源元素。在此语法中，指定的索引以 1 为基础，使用线性索引形式。</p></li><li><p>通常，特定信道或信号函数会生成资源元素索引，将信道或信号符号映射到资源网格。这些索引针对的是 M-by-N-byP 数组中的资源元素。M 是子载波数，N 是 OFDM 符号数，P 是天线端口数。</p></li></ul><p><strong>nrEqualizeMMSE：</strong></p><ul><li><p>[eqSym,csi] = nrEqualizeMMSE(rxSym,hest,nVar) 对物理信道 rxSym 提取的资源元素进行 MMSE 均衡，并在 eqSym 中返回均衡后的符号。</p></li><li><p>均衡过程使用估计的信道信息 hest 和估计的接收噪声方差 nVar。</p></li><li><p>该函数还返回软信道状态信息 csi。</p></li></ul><p><strong>csi的生成过程：</strong></p><ul><li>首先获取变量Qm，根据上述代码可以知道Qm = 2；</li><li>接着生成两行相同的csi<img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307221550047.png" alt="image-20230722155054014"></li><li>最后将csi按照列序号的顺序整合为一列，如下图所示：<img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307221551920.png" alt="image-20230722155134894"></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 绘制均衡化后接收到的 PBCH 星座</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">plot</span>(pbchEq,<span class="string">'o'</span>);</span><br><span class="line">xlabel(<span class="string">'In-Phase'</span>); ylabel(<span class="string">'Quadrature'</span>)</span><br><span class="line">title(<span class="string">'Equalized PBCH Constellation'</span>);</span><br><span class="line">m = <span class="built_in">max</span>(<span class="built_in">abs</span>([<span class="built_in">real</span>(pbchEq(:)); <span class="built_in">imag</span>(pbchEq(:))])) * <span class="number">1.1</span>;</span><br><span class="line">axis([-m m -m m]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% PBCH demodulation</span></span><br><span class="line">pbchBits = nrPBCHDecode(pbchEq,ncellid,v,nest);</span><br></pre></td></tr></tbody></table></figure><hr><ul><li><p>代码的前半部分是对pbchEq进行星座图绘制。</p></li><li><p>星座图采用QPSK调制，故只有四种情况</p></li><li><p>接收到的点围绕着四个基准点分布，如下图所示：</p></li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307221628303.png"></p><p><strong>nrPBCHDecode：</strong></p><ul><li><p>cw = nrPBCHDecode(sym,ncellid,v) 返回执行 TS 38.211 第 7.3.3 节 [1] 中定义的物理广播信道 (PBCH) 逆处理后产生的软比特 cw 向量。</p></li><li><p>cw = nrPBCHDecode(sym,ncellid,v,nVar) 指定 PBCH 解调中软比特的噪声方差缩放因子。</p></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 计算 PBCH EVM 有效值</span></span><br><span class="line">pbchRef = nrPBCH(pbchBits&lt;<span class="number">0</span>,ncellid,v);</span><br><span class="line">evm = comm.EVM;</span><br><span class="line">pbchEVMrms = evm(pbchRef,pbchEq);</span><br><span class="line"></span><br><span class="line"><span class="comment">% Display calculated EVM</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">' PBCH RMS EVM: '</span> num2str(pbchEVMrms,<span class="string">'%0.3f'</span>) <span class="string">'%'</span>]);</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrPBCH：</strong></p><ul><li><p>sym = nrPBCH(cw,ncellid,v) 返回物理层小区标识号 ncellid 的物理广播信道（PBCH）调制符号。</p></li><li><p>该函数实现了 TS 38.211 第 7.3.3 节 [1]。</p></li><li><p>输入 cw 是 BCH 编码字，如 TS 38.212 第 7.1.5 节 [2] 所述。</p></li><li><p>输入 v 指定加扰序列相位。</p></li></ul><p><strong>comm.EVM:</strong></p><ul><li><p>comm.EVM System 对象™ 可测量接收信号的均方根 EVM、最大 EVM 和百分位 EVM。</p></li><li><p>测量接收信号的 EVM：</p><ul><li>创建 comm.EVM 对象并设置其属性。</li><li>调用带参数的对象，就像调用函数一样。</li></ul></li></ul><p><strong>资料：</strong>EVM是数字通信中最常用来表征调制质量的量度。它表示了一个星座点距离其理论位置的偏差。 通常用%RMS 或者 dB作为单位。</p><p><strong>运行结果：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307221714525.png" alt="image-20230722171441500"></p><hr><h3 id="BCH-解码"><a href="#BCH-解码" class="headerlink" title="BCH 解码"></a>BCH 解码</h3><ul><li><p>接收器利用来自 MMSE 均衡器的信道状态信息（CSI）对 BCH 比特估计值进行加权，并对 BCH 解码。</p></li><li><p>BCH 解码包括速率恢复、极性解码、CRC 解码、解扰，以及将 24 个 BCH 传输块比特与 8 个额外的定时相关有效载荷比特分离。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Apply CSI</span></span><br><span class="line">pbchBits = pbchBits .* csi;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 执行 BCH 解码，包括速率恢复、极性解码和 CRC解码。PBCH 解扰和 BCH 传输块的分离</span></span><br><span class="line"><span class="comment">% 还从 8 个附加有效载荷比特 A...A+7 中分离出 "trblk"：</span></span><br><span class="line"><span class="comment">%   A ... A+3: 系统帧编号的 4 个 LSB</span></span><br><span class="line"><span class="comment">%         A+4: 半帧数</span></span><br><span class="line"><span class="comment">% A+5 ... A+7: L_max=64 时，SS/PBCH 块索引的 3 个 MSB</span></span><br><span class="line"><span class="comment">%              当 L_max=4 或 8 时，A+5 为子载波偏移 k_SSB 的 MSB</span></span><br><span class="line">polarListLength = <span class="number">8</span>;</span><br><span class="line">[~,crcBCH,trblk,sfn4lsb,nHalfFrame,msbidxoffset] = ...</span><br><span class="line">    nrBCHDecode(pbchBits,polarListLength,refBurst.L_max,ncellid);</span><br></pre></td></tr></tbody></table></figure><hr><p><strong>nrBCHDecode：</strong></p><p>[<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_b456b0fa-a722-42b3-b910-cb0cd5ea1202"><code>scrblk</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_d6b31f92-0345-4596-b792-7d81344b3c92"><code>errFlag</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_a3fb1d8c-841a-4d1c-b0ee-f5df6a1f60d5"><code>trblk</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_eac2fd57-bb66-44c4-973a-ee828ce18963"><code>lsbofsfn</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_170d642e-e378-47e8-99bc-3ac19b35a3ae"><code>hrf</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_8dc7a95f-0f60-4022-95b1-dbc898ca54ec"><code>msbidxoffset</code></a>] = nrBCHDecode(<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_81ad52b4-e45d-42d5-a887-a263a9a52a84"><code>softbits</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_f6312906-77f9-4dc6-88c2-cd9b4b1e4e10"><code>L</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_7520d265-200d-4ffb-ac12-57a9b16f44b1"><code>lssb</code></a>,<a href="https://www.mathworks.com/help/releases/R2023a/5g/ref/nrbchdecode.html?searchHighlight=nrBCHDecode&amp;s_tid=doc_srchtitle#mw_function_nrBCHDecode_sep_mw_2ff13fd3-5525-44cd-9cb1-83f787db71c7"><code>ncellid</code></a>)</p><ul><li><p>也会返回解码后的 BCH 传输块 trblk。</p></li><li><p>附加输入参数是候选同步信号/物理广播信道 (SS/PBCH) 块的数量 lssb 和物理层小区标识号 ncellid。</p></li><li><p>函数还会返回这些信息元素：</p><ul><li>lsbofsfn，系统帧号的四个最小有效位 (LSB)</li><li>hrf，半帧位</li><li>msbidxoffset，索引偏移的最有效位（MSB）</li></ul></li><li><p><strong>scrblk：</strong>解码加扰 BCH 传输块，以 32×1 二进制列向量形式返回。</p></li><li><p><strong>errFlag：</strong>表示 scrblk 是否包含错误的错误标志，返回值为 0 或 1。如果 errFlag 为 1，则表示发生了错误。</p></li><li><p><strong>trblk：</strong>已解码和解扰的 BCH 传输块，以 24-by-1 二进制列向量形式返回。输出 trblk 是 BCCH-BCH-Message，如 TS 38.331 第 6.2.1 节 [2] 所定义。BCCH-BCH-Message 包含 TS 38.331 第 6.2.2 节定义的主信息块 (MIB)。</p></li><li><p><strong>lsbofsfn：</strong>系统帧编号的四个 LSB，以 4-by-1 列向量形式返回。</p></li><li><p>**hrf:**SS/PBCH 块传输中的半帧位，返回 0 表示帧的前半部分，返回 1 表示帧的后半部分。更多信息，请参见 TS 38.214 第 4.1 节 [3]。</p></li><li><p><strong>msbidxoffset：</strong></p><ul><li>索引偏移的 MSB，以标量或 3×1 列向量形式返回。</li><li>如果 lssb 为 4 或 8，msbidxoffset 是子载波索引的解码 MSB，以标量形式返回。</li><li>如果 lssb 为 64，msbidxoffset 的条目是 SSB 索引的三个解码 MSB，以 3-by-1 列向量形式返回。</li></ul></li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 显示 BCH CRC</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">' BCH CRC: '</span> num2str(crcBCH)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 如果收到的 BCH 有错误，则停止处理 MIB 和 SIB1</span></span><br><span class="line"><span class="keyword">if</span> crcBCH</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">' BCH CRC is not zero.'</span>);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用 "msbidxoffset "值设置 "k_SSB "或 "ssbIndex "的位，具体取决于突发中 SS/PBCH 块的数量</span></span><br><span class="line"><span class="keyword">if</span> (refBurst.L_max==<span class="number">64</span>)</span><br><span class="line">    ssbIndex = ssbIndex + (bit2int(msbidxoffset,<span class="number">3</span>) * <span class="number">8</span>);</span><br><span class="line">    k_SSB = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    k_SSB = msbidxoffset * <span class="number">16</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%  显示 SSB 索引</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">' SSB index: '</span> num2str(ssbIndex)]);</span><br></pre></td></tr></tbody></table></figure><hr><ul><li><p>对于L = 64来说，时间索引一共需要6bit，低3位bit是在DM-RS中获取的，最后三位需要在解码PBCH后获取。因此ssbIndex相比于L  = 4或 8bit需要进一步操作，代码如上所示。</p></li><li><p>根据代码所示对于L= 4/8，还需要获取子载波偏移参数k_SSB。（这里为什么乘以16不太确定，可能是：）</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307222240289.png" alt="image-20230722224038261"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307222240206.png"></p><p>因此MSB应该是k_SSB的第五位，第五位bit就是2^4 = 16。</p></li></ul><p>最终的运行结果为：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307222242226.png" alt="image-20230722224237199"></p><hr><h3 id="MIB-和-BCH-解析"><a href="#MIB-和-BCH-解析" class="headerlink" title="MIB 和 BCH 解析"></a>MIB 和 BCH 解析</h3><ul><li><p>该示例将 24 个解码 BCH 传输块比特解析为 MIB 消息，并创建包含初始系统信息的 initialSystemInfo 结构。</p></li><li><p>这一过程包括根据 MIB 中的 6 个 MSB 和 PBCH 有效载荷比特中的 4 个 LSB 重构 10 位系统帧号（SFN）NFrame。</p></li><li><p>它还包括在每个突发 L_max=4 或 8 个 SS/PBCH 块的情况下，从 PBCH 有效载荷比特中加入子载波偏移 k_SSB 的 MSB。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% 将最后 23 个解码 BCH 传输块比特解析为 MIB 报文。</span></span><br><span class="line"><span class="comment">% BCH 传输块 "trblk "是 RRC 报文 BCCH-BCH-Message,由前导 0 位和与 MIB 相对应的 23 位组成。 </span></span><br><span class="line"><span class="comment">% 前导位表示传输的报文类型（MIB 或空序列）。</span></span><br><span class="line"></span><br><span class="line">mib = fromBits(MIB,trblk(<span class="number">2</span>:<span class="keyword">end</span>)); <span class="comment">% 不解析前导位</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><hr><p><strong>MIB：</strong></p><ul><li>M = MIB 创建主信息块（MIB）无线电资源控制(RRC) 消息，其中包含 TS 38.331 中定义的 MIB 比特字段。该报文使 MIB RRC 的编码和解码成为可能。</li><li>消息比特的编码和解码。所有字段按按格式定义的顺序映射到一组信息比特上。这种映射的方式是，每个字段的最重要位被映射到最低阶的信息位。与每个字段相关的比特数是固定的。</li><li>信息比特由广播信道（BCH）编码，并在物理广播信道（PBCH）上传输。BCH 传输块是 RRC 信息BCH-BCH-Message，由前导 0 比特和 23 比特组成。与 MIB 相对应。前导位表示传输的报文类型(MIB 或空序列）。</li></ul><p><strong>initSystemInfo：</strong></p><ul><li>创建由已解码 MIB 第 7 位指示的子载波间隔集。</li><li>这组间隔对于 FR1（L_max=4 或 8）和 FR2（L_max=64）是不同的。</li></ul><hr><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建包含完整初始系统信息的结构</span></span><br><span class="line">initialSystemInfo = initSystemInfo(mib,sfn4lsb,k_SSB,refBurst.L_max);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示 MIB 结构</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">' BCH/MIB Content:'</span>)</span><br><span class="line"><span class="built_in">disp</span>(initialSystemInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 根据 TS 38.213 第 4.1 节，检查是否存在用于 Type0-PDCCH 公共搜索空间 (CSS) 的 CORESET</span></span><br><span class="line"><span class="keyword">if</span> ~isCORESET0Present(refBurst.BlockPattern,initialSystemInfo.k_SSB)</span><br><span class="line">    fprintf(<span class="string">'CORESET 0 is not present (k_SSB &gt; k_SSB_max).\n'</span>);</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><hr><p><strong>initSystemInfo代码如下所示：</strong>【就是一个初始化代码】</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initSystemInfo</span> = <span class="title">initSystemInfo</span><span class="params">(mib,sfn4lsb,k_SSB,L_max)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Create set of subcarrier spacings signaled by the 7th bit of the</span></span><br><span class="line">    <span class="comment">% decoded MIB, the set is different for FR1 (L_max=4 or 8) and FR2</span></span><br><span class="line">    <span class="comment">% (L_max=64)</span></span><br><span class="line">    <span class="keyword">if</span> (L_max==<span class="number">64</span>)</span><br><span class="line">        scsCommon = [<span class="number">60</span> <span class="number">120</span>];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        scsCommon = [<span class="number">15</span> <span class="number">30</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    initSystemInfo = struct();</span><br><span class="line">    initSystemInfo.NFrame = mib.systemFrameNumber*<span class="number">2</span>^<span class="number">4</span> + bit2int(sfn4lsb,<span class="number">4</span>);</span><br><span class="line">    initSystemInfo.SubcarrierSpacingCommon = scsCommon(mib.subCarrierSpacingCommon + <span class="number">1</span>);</span><br><span class="line">    initSystemInfo.k_SSB = k_SSB + mib.ssb_SubcarrierOffset;</span><br><span class="line">    initSystemInfo.DMRSTypeAPosition = <span class="number">2</span> + mib.dmrs_TypeA_Position;</span><br><span class="line">    initSystemInfo.PDCCHConfigSIB1 = info(mib.pdcch_ConfigSIB1);</span><br><span class="line">    initSystemInfo.CellBarred = mib.cellBarred;</span><br><span class="line">    initSystemInfo.IntraFreqReselection = mib.intraFreqReselection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p><strong>运行结果如下图所示：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307222330624.png" alt="image-20230722233033590"></p><hr><p><strong>isCORESET0Present:</strong></p><p><strong>代码如下：</strong></p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">present</span> = <span class="title">isCORESET0Present</span><span class="params">(ssbBlockPattern,kSSB)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ssbBlockPattern</span><br><span class="line">        <span class="keyword">case</span> {<span class="string">'Case A'</span>,<span class="string">'Case B'</span>,<span class="string">'Case C'</span>} <span class="comment">% FR1</span></span><br><span class="line">            kssb_max = <span class="number">23</span>;</span><br><span class="line">        <span class="keyword">case</span> {<span class="string">'Case D'</span>,<span class="string">'Case E'</span>} <span class="comment">% FR2</span></span><br><span class="line">            kssb_max = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (kSSB &lt;= kssb_max)</span><br><span class="line">        present = <span class="built_in">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        present = <span class="built_in">false</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>代码的意思是根据pattern检测子载波偏移是否小于最大偏移量。</p>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NR SSB Beam Sweeping translation</title>
      <link href="/2023/07/13/NR%20SSB%20Beam%20Sweeping/"/>
      <url>/2023/07/13/NR%20SSB%20Beam%20Sweeping/</url>
      
        <content type="html"><![CDATA[<h2 id="NR-SSB波束扫频"><a href="#NR-SSB波束扫频" class="headerlink" title="NR SSB波束扫频"></a>NR SSB波束扫频</h2><p>本示例展示了如何在5G NR系统的发射端（gNB）和接收端（UE）采用波束扫描。</p><p>本示例使用同步信号块（SSB）说明了初始接入期间使用的一些波束管理程序。</p><p>为了完成波束扫描，本示例使用了相控阵系统工具箱™中的几个组件。</p><hr><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>毫米波频率的支持需要定向链路，这导致了用于NR初始接入的波束管理程序的规范。</p><p>波束管理是一组第一层（物理）和第二层（介质访问控制）程序，用于获取和维护一组波束对链路（gNB使用的波束与UE使用的波束配对）。</p><p>波束管理程序适用于下行链路和上行链路的传输和接收[ 1 ]、[ 2 ]。<strong>这些程序包括：</strong></p><ul><li>波束扫频</li><li>波束测量</li><li>波束确定</li><li>波束检测</li><li>波束恢复</li></ul><hr><p>本示例侧重于在<strong>用户设备（UE）</strong>和接入网节点（gNB）之间建立连接时空闲用户的初始接入程序。</p><p>在物理层，使用同步信号块（SSB）作为下行链路方向（gNB到UE）的突发信号传输。</p><p>本示例突出了发射/接收点（TRP）波束扫描和UE波束扫描，以建立波束对链路。在多种波束管理程序中，TR 38.802将这种双端扫频定义为程序P-1[ 1 ]。</p><hr><p>一旦连接，同一波束对链路可用于后续传输。如有必要，可使用CSI-RS（用于下行链路）和SRS（用于上行链路）进一步完善波束。如果波束失效，可重新建立波束对链路。有关波束对细化的示例，请参见使用CSI-RS的NR下行链路发送端<strong>波束细化</strong>。</p><p>[1]: <a href="https://ww2.mathworks.cn/help/5g/ug/nr-downlink-transmit-end-beam-refinement-using-csi-rs.html">https://ww2.mathworks.cn/help/5g/ug/nr-downlink-transmit-end-beam-refinement-using-csi-rs.html</a>“NR Downlink Transmit-End Beam Refinement Using CSI-RS”</p><hr><ul><li><p>该示例生成一个NR同步信号脉冲串，对脉冲串中的每个SSB进行波束成形，以扫过<strong>方位角</strong>和<strong>仰角</strong>方向，通过空间散射信道传输该波束成形信号，并通过<strong>多个接收端波束</strong>处理该接收信号。</p></li><li><p>该示例测量每个发射-接收波束对（双回路）的<strong>参考信号接收功率（RSRP）</strong>，并确定RSRP最大的波束对链路。</p></li><li><p>因此，该波束对链路是模拟空间场景下发射端和接收端的<strong>最佳波束对</strong>。该图显示了主要的处理步骤，波束管理步骤用彩色标出。</p></li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307132155692.png" alt="流程图"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rng(211);                           % 设置RNG状态以实现可重复性</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="模拟参数"><a href="#模拟参数" class="headerlink" title="模拟参数"></a>模拟参数</h3><p>为示例定义系统参数。修改这些参数，以了解它们对系统的影响。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">prm.NCellID = <span class="number">1</span>;                    <span class="comment">% 小区 ID</span></span><br><span class="line">prm.FreqRange = <span class="string">'FR1'</span>;              <span class="comment">% 频率范围: 'FR1' 或者 'FR2'</span></span><br><span class="line">prm.CenterFreq = <span class="number">3.5e9</span>;             <span class="comment">% 频率单位：赫兹</span></span><br><span class="line">prm.SSBlockPattern = <span class="string">'Case B'</span>;      <span class="comment">% Case A/B/C/D/E</span></span><br><span class="line">prm.SSBTransmitted = [<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">8</span>) <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">0</span>)];   <span class="comment">% 4/8 or 64 in length</span></span><br><span class="line"></span><br><span class="line">prm.TxArraySize = [<span class="number">8</span> <span class="number">8</span>];            <span class="comment">% 传输数组大小，[行 列］</span></span><br><span class="line">prm.TxAZlim = [<span class="number">-60</span> <span class="number">60</span>];             <span class="comment">% 发射方位角扫描限制</span></span><br><span class="line">prm.TxELlim = [<span class="number">-90</span> <span class="number">0</span>];              <span class="comment">% 发射高程扫描限制</span></span><br><span class="line"></span><br><span class="line">prm.RxArraySize = [<span class="number">2</span> <span class="number">2</span>];            <span class="comment">% 接收数组大小, [行列数]</span></span><br><span class="line">prm.RxAZlim = [<span class="number">-180</span> <span class="number">180</span>];           <span class="comment">% 接收方位角扫描限制</span></span><br><span class="line">prm.RxELlim = [<span class="number">0</span> <span class="number">90</span>];               <span class="comment">% 接收高程扫描限制</span></span><br><span class="line"></span><br><span class="line">prm.ElevationSweep = <span class="built_in">false</span>;         <span class="comment">% 启用/禁用仰角扫描</span></span><br><span class="line">prm.SNRdB = <span class="number">30</span>;                     <span class="comment">% 信噪比, dB</span></span><br><span class="line">prm.RSRPMode = <span class="string">'SSSwDMRS'</span>;          <span class="comment">% {'SSSwDMRS', 'SSSonly'}</span></span><br></pre></td></tr></tbody></table></figure><p>示例中使用了这些参数：</p><ul><li>单个BS和UE的单小区情况下的小区ID。</li><li>频率范围，以字符串形式指定 FR1 或 FR2 操作。</li><li>中心频率，单位Hz，取决于频率范围。</li><li>同步信号块模式，FR1 为情况 A/B/C，FR2 为情况 D/E。这也选择了子载波间隔。</li><li>模式中传输的 SSB，对于 FR1 为长度为 4 或 8 的二进制矢量，对于 FR2 为长度为 64 的二进制矢量。传输的 SSB 数设定发射端和接收端的波束数。</li><li>发射阵列尺寸，作为双元素行向量，分别指定发射阵列行和列的天线元素数。<strong>当两个值都大于1时，使用均匀矩形阵列（URA）</strong>。</li><li>发射方位角扫描限制（度），指定扫描的起始和终止方位角。</li><li>发射仰角扫描限值，单位为度，用于指定扫描的起始和终止仰角。</li><li>接收阵列尺寸，作为双元素行向量，分别指定接收阵列行和列的天线元素数。<strong>当两个值都大于1时，使用均匀矩形阵列（URA）</strong>。</li><li>以度为单位的接收方位角扫描限值，用于指定扫描的起始和终止方位角。</li><li>以度为单位的接收仰角扫描限值，用于指定扫描的起始和终止仰角。</li><li>启用或禁用发射端和接收端的仰角扫描。为 FR2 和/或 URA 启用仰角扫描。</li><li>信噪比（dB）。</li><li>SSB 测量模式，指定仅使用辅助同步信号（’SSSonly’）或使用 PBCH DM-RS 以及辅助同步信号（’SSSwDMRS’）。</li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prm = validateParams(prm);</span><br></pre></td></tr></tbody></table></figure><p>validatteParams是一个本地函数，代码如下：</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prm</span> = <span class="title">validateParams</span><span class="params">(prm)</span></span></span><br><span class="line"><span class="comment">% 验证用户指定的参数并返回更新的参数。</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% 仅对参数的一致性进行交叉检查。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> strcmpi(prm.FreqRange,<span class="string">'FR1'</span>)</span><br><span class="line">        <span class="keyword">if</span> prm.CenterFreq &gt; <span class="number">7.125e9</span> || prm.CenterFreq &lt; <span class="number">410e6</span></span><br><span class="line">            error([<span class="string">'Specified center frequency is outside the FR1 '</span>, ...</span><br><span class="line">                   <span class="string">'frequency range (410 MHz - 7.125 GHz).'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> strcmpi(prm.SSBlockPattern,<span class="string">'Case D'</span>) ||  ...</span><br><span class="line">           strcmpi(prm.SSBlockPattern,<span class="string">'Case E'</span>)</span><br><span class="line">            error([<span class="string">'Invalid SSBlockPattern for selected FR1 frequency '</span> ...</span><br><span class="line">                <span class="string">'range. SSBlockPattern must be one of ''Case A'' or '</span> ...</span><br><span class="line">                <span class="string">'''Case B'' or ''Case C'' for FR1.'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ~((<span class="built_in">length</span>(prm.SSBTransmitted)==<span class="number">4</span>) || ...</span><br><span class="line">             (<span class="built_in">length</span>(prm.SSBTransmitted)==<span class="number">8</span>))</span><br><span class="line">            error([<span class="string">'SSBTransmitted must be a vector of length 4 or 8'</span>, ...</span><br><span class="line">                   <span class="string">'for FR1 frequency range.'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (prm.CenterFreq &lt;= <span class="number">3e9</span>) &amp;&amp; (<span class="built_in">length</span>(prm.SSBTransmitted)~=<span class="number">4</span>)</span><br><span class="line">            error([<span class="string">'SSBTransmitted must be a vector of length 4 for '</span> ...</span><br><span class="line">                   <span class="string">'center frequency less than or equal to 3GHz.'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (prm.CenterFreq &gt; <span class="number">3e9</span>) &amp;&amp; (<span class="built_in">length</span>(prm.SSBTransmitted)~=<span class="number">8</span>)</span><br><span class="line">            error([<span class="string">'SSBTransmitted must be a vector of length 8 for '</span>, ...</span><br><span class="line">                   <span class="string">'center frequency greater than 3GHz and less than '</span>, ...</span><br><span class="line">                   <span class="string">'or equal to 7.125GHz.'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">% 'FR2'</span></span><br><span class="line">        <span class="keyword">if</span> prm.CenterFreq &gt; <span class="number">52.6e9</span> || prm.CenterFreq &lt; <span class="number">24.25e9</span></span><br><span class="line">            error([<span class="string">'Specified center frequency is outside the FR2 '</span>, ...</span><br><span class="line">                   <span class="string">'frequency range (24.25 GHz - 52.6 GHz).'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> ~(strcmpi(prm.SSBlockPattern,<span class="string">'Case D'</span>) || ...</span><br><span class="line">                strcmpi(prm.SSBlockPattern,<span class="string">'Case E'</span>))</span><br><span class="line">            error([<span class="string">'Invalid SSBlockPattern for selected FR2 frequency '</span> ...</span><br><span class="line">                <span class="string">'range. SSBlockPattern must be either ''Case D'' or '</span> ...</span><br><span class="line">                <span class="string">'''Case E'' for FR2.'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">length</span>(prm.SSBTransmitted)~=<span class="number">64</span></span><br><span class="line">            error([<span class="string">'SSBTransmitted must be a vector of length 64 for '</span>, ...</span><br><span class="line">                   <span class="string">'FR2 frequency range.'</span>]);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    prm.NumTx = prod(prm.TxArraySize);</span><br><span class="line">    prm.NumRx = prod(prm.RxArraySize);</span><br><span class="line">    <span class="keyword">if</span> prm.NumTx==<span class="number">1</span> || prm.NumRx==<span class="number">1</span></span><br><span class="line">        error([<span class="string">'Number of transmit or receive antenna elements must be'</span>, ...</span><br><span class="line">               <span class="string">' greater than 1.'</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    prm.IsTxURA = (prm.TxArraySize(<span class="number">1</span>)&gt;<span class="number">1</span>) &amp;&amp; (prm.TxArraySize(<span class="number">2</span>)&gt;<span class="number">1</span>);</span><br><span class="line">    prm.IsRxURA = (prm.RxArraySize(<span class="number">1</span>)&gt;<span class="number">1</span>) &amp;&amp; (prm.RxArraySize(<span class="number">2</span>)&gt;<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ~( strcmpi(prm.RSRPMode,<span class="string">'SSSonly'</span>) || ...</span><br><span class="line">          strcmpi(prm.RSRPMode,<span class="string">'SSSwDMRS'</span>) )</span><br><span class="line">        error([<span class="string">'Invalid RSRP measuring mode. Specify either '</span>, ...</span><br><span class="line">               <span class="string">'''SSSonly'' or ''SSSwDMRS'' as the mode.'</span>]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">% Select SCS based on SSBlockPattern</span></span><br><span class="line">    <span class="keyword">switch</span> lower(prm.SSBlockPattern)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'case a'</span></span><br><span class="line">            scs = <span class="number">15</span>;</span><br><span class="line">            cbw = <span class="number">10</span>;</span><br><span class="line">            scsCommon = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">case</span> {<span class="string">'case b'</span>, <span class="string">'case c'</span>}</span><br><span class="line">            scs = <span class="number">30</span>;</span><br><span class="line">            cbw = <span class="number">25</span>;</span><br><span class="line">            scsCommon = <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'case d'</span></span><br><span class="line">            scs = <span class="number">120</span>;</span><br><span class="line">            cbw = <span class="number">100</span>;</span><br><span class="line">            scsCommon = <span class="number">120</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'case e'</span></span><br><span class="line">            scs = <span class="number">240</span>;</span><br><span class="line">            cbw = <span class="number">200</span>;</span><br><span class="line">            scsCommon = <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    prm.SCS = scs;</span><br><span class="line">    prm.ChannelBandwidth = cbw;</span><br><span class="line">    prm.SubcarrierSpacingCommon = scsCommon;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p><strong>代码理解：</strong></p><ul><li><p>前半部分用于判断属于FR1频段还是FR2频段，如果在属于某一频段范围的前提下，其某项指标不满足相应的条件，则会报错。</p></li><li><p>prm.NumTx 用于计算总天线数，必须要大于1，否则会报错。</p></li><li><p>文档中指示当两个值都大于1时，使用均匀矩形阵列（URA）。</p></li><li><p>下面进行SSB测量模式选择。</p></li><li><p>最后进行SSB锁定模式，通过case选择后，最后对参数进行赋值。</p></li></ul><hr><h3 id="同步信号突发配置"><a href="#同步信号突发配置" class="headerlink" title="同步信号突发配置"></a>同步信号突发配置</h3><p>使用指定的系统参数设置同步信号脉冲串参数。初始接入时，将SSB周期设为20ms。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">txBurst = nrWavegenSSBurstConfig;</span><br><span class="line">txBurst.BlockPattern = prm.SSBlockPattern;</span><br><span class="line">txBurst.TransmittedBlocks = prm.SSBTransmitted;</span><br><span class="line">txBurst.Period = <span class="number">20</span>;</span><br><span class="line">txBurst.SubcarrierSpacingCommon = prm.SubcarrierSpacingCommon;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 配置 nrDLCarrierConfig 对象以使用同步信号</span></span><br><span class="line"><span class="comment">% 该对象用于设置突发参数和禁用其他通道。nrWaveformGenerator 将使用该对象生成 SS burst 波形。</span></span><br><span class="line"></span><br><span class="line">cfgDL = configureWaveformGenerator(prm,txBurst);</span><br></pre></td></tr></tbody></table></figure><p>首先查询 <em>nrWavegenSSBurstConfig</em> 是什么：</p><p><em>nrWavegenSSBurstConfig</em> ：用于生成5G波形的SS突发配置参数</p><p><strong>说明：</strong></p><ul><li><p>nrWavegenSSBurstConfig 对象设置同步信号（SS）突发配置参数。在配置 5G 下行链路波形生成时，使用该对象设置 nrDLCarrierConfig 对象的 SSBurst 属性。</p></li><li><p>该对象定义 SS burst 的子载波间隔 (SCS)、时域和频域分配、功率和有效载荷。</p></li><li><p>默认的 nrWavegenSSBurstConfig 对象将 SS burst 配置为四个活动 SS 块，周期为 20 ms，与初始小区选择相对应。默认配置还指定SS突发携带主信息块（MIB），并将SS突发置于子载波间隔为15 kHz的载波中心（块模式情况A）。要更新SS突发的频率位置，请将NCRBSSB和KSSB对象属性设置为非空值。</p></li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307142017047.png" alt="参数1"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307142017275.png" alt="参数2"></p><hr><p>下面是另一个本地函数configureWaveformGenerator：</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cfgDL</span> = <span class="title">configureWaveformGenerator</span><span class="params">(prm,txBurst)</span></span></span><br><span class="line"><span class="comment">% 配置nrWaveformGenerator使用的nrDLCarrierConfig对象。</span></span><br><span class="line"><span class="comment">% 产生SS脉冲串波形。</span></span><br><span class="line"></span><br><span class="line">    cfgDL = nrDLCarrierConfig;</span><br><span class="line">    cfgDL.SCSCarriers{<span class="number">1</span>}.SubcarrierSpacing = prm.SCS;</span><br><span class="line">    <span class="keyword">if</span> (prm.SCS==<span class="number">240</span>)</span><br><span class="line">        cfgDL.SCSCarriers = [cfgDL.SCSCarriers cfgDL.SCSCarriers];</span><br><span class="line">        cfgDL.SCSCarriers{<span class="number">2</span>}.SubcarrierSpacing = prm.SubcarrierSpacingCommon;</span><br><span class="line">        cfgDL.BandwidthParts{<span class="number">1</span>}.SubcarrierSpacing = prm.SubcarrierSpacingCommon;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cfgDL.BandwidthParts{<span class="number">1</span>}.SubcarrierSpacing = prm.SCS;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    cfgDL.PDSCH{<span class="number">1</span>}.Enable = <span class="built_in">false</span>;</span><br><span class="line">    cfgDL.PDCCH{<span class="number">1</span>}.Enable = <span class="built_in">false</span>;</span><br><span class="line">    cfgDL.ChannelBandwidth = prm.ChannelBandwidth;</span><br><span class="line">    cfgDL.FrequencyRange = prm.FreqRange;</span><br><span class="line">    cfgDL.NCellID = prm.NCellID;</span><br><span class="line">    cfgDL.NumSubframes = <span class="number">5</span>;</span><br><span class="line">    cfgDL.WindowingPercent = <span class="number">0</span>;</span><br><span class="line">    cfgDL.SSBurst = txBurst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307142021729.png" alt="属性列表"></p><hr><h3 id="脉冲发生器"><a href="#脉冲发生器" class="headerlink" title="脉冲发生器"></a>脉冲发生器</h3><p>调用 nrWaveformGenerator 函数创建 SS burst 波形[ 3 ]。生成的波形尚未波束成形。</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">burstWaveform = nrWaveformGenerator(cfgDL);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 显示SS脉冲串波形的频谱图</span></span><br><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">ofdmInfo = nrOFDMInfo(cfgDL.SCSCarriers{<span class="number">1</span>}.NSizeGrid,prm.SCS);</span><br><span class="line">nfft = ofdmInfo.Nfft;</span><br><span class="line">spectrogram(burstWaveform,<span class="built_in">ones</span>(nfft,<span class="number">1</span>),<span class="number">0</span>,nfft,<span class="string">'centered'</span>,ofdmInfo.SampleRate,<span class="string">'yaxis'</span>,<span class="string">'MinThreshold'</span>,<span class="number">-130</span>);</span><br><span class="line">title(<span class="string">'Spectrogram of SS burst waveform'</span>)</span><br></pre></td></tr></tbody></table></figure><p>最后可以跑出来这样一个代码，应该是SSB的样子了</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307142135297.png" alt="image-20230714213556262"></p><hr><h3 id="通道配置"><a href="#通道配置" class="headerlink" title="通道配置"></a>通道配置</h3><ul><li><p>配置空间散射 MIMO 信道。该信道模型对输入应用<strong>自由空间路径损耗</strong>和可选的<strong>其他大气衰减</strong>。</p></li><li><p>在直角坐标系中以[x,y,z]坐标指定<strong>BS</strong>和<strong>UE</strong>的位置。</p></li><li><p>根据指定的阵列尺寸，采用<strong>均匀线性阵列（ULA）</strong>或<strong>均匀矩形阵列（URA）</strong>。</p></li><li><p>阵列采用<strong>各向同性</strong>天线元件。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">c = physconst(<span class="string">'LightSpeed'</span>);   <span class="comment">% 传播速度</span></span><br><span class="line">lambda = c/prm.CenterFreq;     <span class="comment">% 波长</span></span><br><span class="line"></span><br><span class="line">prm.posTx = [<span class="number">0</span>;<span class="number">0</span>;<span class="number">0</span>];           <span class="comment">% 发射阵列位置，[x;y;z]，米</span></span><br><span class="line">prm.posRx = [<span class="number">100</span>;<span class="number">50</span>;<span class="number">0</span>];        <span class="comment">% 接收阵列位置，[x;y;z]，米</span></span><br><span class="line"></span><br><span class="line">toRxRange = rangeangle(prm.posTx,prm.posRx);</span><br><span class="line"><span class="comment">% rangeangle 函数用于确定信号从一个源点或一组源点到一个参考点的传播路径长度和路径方向。</span></span><br><span class="line">spLoss = fspl(toRxRange,lambda);   <span class="comment">% 自由空间路径损耗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 发射阵列</span></span><br><span class="line"><span class="keyword">if</span> prm.IsTxURA</span><br><span class="line">    <span class="comment">% 均匀矩形阵列</span></span><br><span class="line">    arrayTx = phased.URA(prm.TxArraySize,<span class="number">0.5</span>*lambda, ...</span><br><span class="line">        <span class="string">'Element'</span>,phased.IsotropicAntennaElement(<span class="string">'BackBaffled'</span>,<span class="built_in">true</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% 均匀线性阵列</span></span><br><span class="line">    arrayTx = phased.ULA(prm.NumTx, ...</span><br><span class="line">        <span class="string">'ElementSpacing'</span>,<span class="number">0.5</span>*lambda, ...</span><br><span class="line">        <span class="string">'Element'</span>,phased.IsotropicAntennaElement(<span class="string">'BackBaffled'</span>,<span class="built_in">true</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 接收阵列</span></span><br><span class="line"><span class="keyword">if</span> prm.IsRxURA</span><br><span class="line">    <span class="comment">% 均匀矩形阵列</span></span><br><span class="line">    arrayRx = phased.URA(prm.RxArraySize,<span class="number">0.5</span>*lambda, ...</span><br><span class="line">        <span class="string">'Element'</span>,phased.IsotropicAntennaElement);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% 均匀线性阵列</span></span><br><span class="line">    arrayRx = phased.ULA(prm.NumRx, ...</span><br><span class="line">        <span class="string">'ElementSpacing'</span>,<span class="number">0.5</span>*lambda, ...</span><br><span class="line">        <span class="string">'Element'</span>,phased.IsotropicAntennaElement);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 散射器位置</span></span><br><span class="line">prm.FixedScatMode = <span class="built_in">true</span>;</span><br><span class="line"><span class="keyword">if</span> prm.FixedScatMode</span><br><span class="line">    <span class="comment">% 固定单个散射体位置</span></span><br><span class="line">    prm.ScatPos = [<span class="number">50</span>; <span class="number">80</span>; <span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% 在随机位置产生散射体</span></span><br><span class="line">    Nscat = <span class="number">10</span>;        <span class="comment">% 散射体数量</span></span><br><span class="line">    azRange = <span class="number">-180</span>:<span class="number">180</span>;</span><br><span class="line">    elRange = <span class="number">-90</span>:<span class="number">90</span>;</span><br><span class="line">    randAzOrder = randperm(<span class="built_in">length</span>(azRange));</span><br><span class="line">    randElOrder = randperm(<span class="built_in">length</span>(elRange));</span><br><span class="line">    azAngInSph = azRange(randAzOrder(<span class="number">1</span>:Nscat));</span><br><span class="line">    elAngInSph = elRange(randElOrder(<span class="number">1</span>:Nscat));</span><br><span class="line">    r = <span class="number">20</span>;            <span class="comment">% 半径</span></span><br><span class="line">    [x,y,z] = <span class="built_in">sph2cart</span>(deg2rad(azAngInSph),deg2rad(elAngInSph),r);</span><br><span class="line">    prm.ScatPos = [x;y;z] + (prm.posTx + prm.posRx)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 配置通道</span></span><br><span class="line">channel = phased.ScatteringMIMOChannel;</span><br><span class="line">channel.PropagationSpeed = c;</span><br><span class="line">channel.CarrierFrequency = prm.CenterFreq;</span><br><span class="line">channel.SampleRate = ofdmInfo.SampleRate;</span><br><span class="line">channel.SimulateDirectPath = <span class="built_in">false</span>;</span><br><span class="line">channel.ChannelResponseOutputPort = <span class="built_in">true</span>;</span><br><span class="line">channel.Polarization = <span class="string">'None'</span>;</span><br><span class="line">channel.TransmitArray = arrayTx;</span><br><span class="line">channel.TransmitArrayPosition = prm.posTx;</span><br><span class="line">channel.ReceiveArray = arrayRx;</span><br><span class="line">channel.ReceiveArrayPosition = prm.posRx;</span><br><span class="line">channel.ScattererSpecificationSource = <span class="string">'Property'</span>;</span><br><span class="line">channel.ScattererPosition = prm.ScatPos;</span><br><span class="line">channel.ScattererCoefficient = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">size</span>(prm.ScatPos,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取最大通道延迟</span></span><br><span class="line">[~,~,tau] = channel(<span class="built_in">complex</span>(<span class="built_in">randn</span>(ofdmInfo.SampleRate*<span class="number">1e-3</span>,prm.NumTx), ...</span><br><span class="line">    <span class="built_in">randn</span>(ofdmInfo.SampleRate*<span class="number">1e-3</span>,prm.NumTx)));</span><br><span class="line">maxChDelay = <span class="built_in">ceil</span>(<span class="built_in">max</span>(tau)*ofdmInfo.SampleRate);</span><br></pre></td></tr></tbody></table></figure><hr><h3 id="发射端波束扫描"><a href="#发射端波束扫描" class="headerlink" title="发射端波束扫描"></a>发射端波束扫描</h3><ul><li><p>为实现TRP波束扫描，使用模拟波束成形对生成的突发中的<strong>每个SS块进行波束成形</strong>。</p></li><li><p>根据突发中SS块的数量和指定的扫描范围，确定不同波束的<strong>方位角</strong>和<strong>仰角</strong>方向。</p></li><li><p>然后将脉冲串中的各个块波束<strong>成形到每个方向</strong>。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 发射端和接收端的波束数</span></span><br><span class="line">numBeams = sum(txBurst.TransmittedBlocks);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 等间距方位角和仰角发射光束</span></span><br><span class="line">azBW = beamwidth(arrayTx,prm.CenterFreq,<span class="string">'Cut'</span>,<span class="string">'Azimuth'</span>);</span><br><span class="line">elBW = beamwidth(arrayTx,prm.CenterFreq,<span class="string">'Cut'</span>,<span class="string">'Elevation'</span>);</span><br><span class="line">txBeamAng = hGetBeamSweepAngles(numBeams,prm.TxAZlim,prm.TxELlim, ...</span><br><span class="line">    azBW,elBW,prm.ElevationSweep);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用于评估发射侧转向权重</span></span><br><span class="line">SteerVecTx = phased.SteeringVector(<span class="string">'SensorArray'</span>,arrayTx, ...</span><br><span class="line">    <span class="string">'PropagationSpeed'</span>,c);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 获取每个SSB占用的OFDM符号集</span></span><br><span class="line">numBlocks = <span class="built_in">length</span>(txBurst.TransmittedBlocks);</span><br><span class="line">burstStartSymbols = ssBurstStartSymbols(txBurst.BlockPattern,numBlocks);</span><br><span class="line">burstStartSymbols = burstStartSymbols(txBurst.TransmittedBlocks==<span class="number">1</span>);</span><br><span class="line">burstOccupiedSymbols = burstStartSymbols.' + (<span class="number">1</span>:<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 为每个SSB的每个OFDM符号应用转向</span></span><br><span class="line">gridSymLengths = <span class="built_in">repmat</span>(ofdmInfo.SymbolLengths,<span class="number">1</span>,cfgDL.NumSubframes);</span><br><span class="line"><span class="comment">% 在numTx上重复突发，为转向做准备</span></span><br><span class="line">strTxWaveform = <span class="built_in">repmat</span>(burstWaveform,<span class="number">1</span>,prm.NumTx)./<span class="built_in">sqrt</span>(prm.NumTx);</span><br><span class="line"><span class="keyword">for</span> ssb = <span class="number">1</span>:numBeams</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 从脉冲串中提取SSB波形</span></span><br><span class="line">    blockSymbols = burstOccupiedSymbols(ssb,:);</span><br><span class="line">    startSSBInd = sum(gridSymLengths(<span class="number">1</span>:blockSymbols(<span class="number">1</span>)<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">    endSSBInd = sum(gridSymLengths(<span class="number">1</span>:blockSymbols(<span class="number">4</span>)));</span><br><span class="line">    ssbWaveform = strTxWaveform(startSSBInd:endSSBInd,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 生成转向权重</span></span><br><span class="line">    wT = SteerVecTx(prm.CenterFreq,txBeamAng(:,ssb));</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 将每个发射单元的权重应用于 SSB</span></span><br><span class="line">    strTxWaveform(startSSBInd:endSSBInd,:) = ssbWaveform.*(wT');</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><hr><p>下面是接收端的，明天再看</p><h3 id="接收端波束扫描和测量"><a href="#接收端波束扫描和测量" class="headerlink" title="接收端波束扫描和测量"></a>接收端波束扫描和测量</h3><h3 id="波束确定"><a href="#波束确定" class="headerlink" title="波束确定"></a>波束确定</h3>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
          <category> MATLAB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>下行同步原理</title>
      <link href="/2023/07/12/%E4%B8%8B%E8%A1%8C%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/12/%E4%B8%8B%E8%A1%8C%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="同步过程"><a href="#同步过程" class="headerlink" title="同步过程"></a>同步过程</h2><p><strong>还是用以下一张简单的图进行描述：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141334927.png"></p><p>首先通过同步PSS获取NID（2），其次通过获取SSS获取NID（1），然后通过PBCH读取MIB中的信息，通过PDCCH获取SIB1的调度信息，最后通过PDSCH读取SIB1信息。</p><p>因此我们首先需要做的就是同步，根据知乎上的讲解，<strong>同步需要有以下准备：</strong></p><hr><h2 id="5G-NR中采用的同步序列"><a href="#5G-NR中采用的同步序列" class="headerlink" title="5G NR中采用的同步序列"></a>5G NR中采用的同步序列</h2><h3 id="m序列："><a href="#m序列：" class="headerlink" title="m序列："></a>m序列：</h3><ul><li><p>简单来讲m序列是通过n位寄存器通过循环移位的方式生成的，且m序列的长度为2^n - 1，m序列的循环移位依然是m序列。</p></li><li><p>m序列最显著的性质是序列中1比0多一个，并且具有良好的自相关性。m多项式也有自己的本原多项式，多项式和生成序列的电路图可以对应起来。</p></li><li><p>对于5G NR同步来讲，根据知乎的讲解，我们使用的应该是127位长的m序列，因此需要个7寄存器。</p></li></ul><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span>=<span class="title">mseq</span><span class="params">(coef)</span>  </span></span><br><span class="line">m=<span class="built_in">length</span>(coef);<span class="comment">%确定寄存器数目  </span></span><br><span class="line">N=<span class="number">2</span>^m<span class="number">-1</span>;<span class="comment">%确定周期  </span></span><br><span class="line"><span class="comment">%mback=0;%用于存放反馈值  </span></span><br><span class="line">y=<span class="built_in">zeros</span>(<span class="number">1</span>,N);<span class="comment">%用于存放输出序列  </span></span><br><span class="line">registers=[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>];<span class="comment">%确定寄存器初始值  </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N  </span><br><span class="line">y(<span class="built_in">i</span>)=registers(m);  </span><br><span class="line">mback=<span class="built_in">mod</span>(sum(coef.*registers),<span class="number">2</span>);  </span><br><span class="line">registers=[mback registers(<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)];  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p>这个程序就是用于生成m序列的matlab程序，注意这个程序计算出长度为7的m序列，因为registers只有七位。并且一定要保证多项式是正确的，否则无法正常生成序列。<strong>举例如下图所示：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141441782.png"></p><p>最后可以生成长度为127的m序列：<img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141442631.png"></p><hr><h3 id="Gold序列："><a href="#Gold序列：" class="headerlink" title="Gold序列："></a>Gold序列：</h3><p>Gold码由一对m序列优选对循环移位构成。</p><p>通过生成两个m序列逐位模二加，生成的序列为Gold序列，同样Gold序列通过移位仍为Gold序列，和m序列具有相似的性质，但Gold序列具有尖锐的相关峰，且互相关值较小。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141452373.jpeg"></p><p><strong>可以参考在雪山灰虎上的例题：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141453368.png"></p><hr><h3 id="ZC序列："><a href="#ZC序列：" class="headerlink" title="ZC序列："></a>ZC序列：</h3><p>ZC(Zadoff –Chu)序列，由Zadoff 和Chu共同发现，ZC序列为欧拉复数序列，是复平面坐标上的单位圆上的点组成的序列 ，每个点对应一对（I, Q）的幅度值。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141500780.jpeg"></p><p>MATLAB中生成ZC序列的代码为:</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZC = zadoffChuSeq(R,N);  </span><br></pre></td></tr></tbody></table></figure><p>根据MATLAB官方解释可以看出：</p><p><code>seq = zadoffChuSeq(R,N)</code> generates the <code>R</code>th root Zadoff-Chu sequence with length <code>N</code>, as defined in 3GPP TS 36.211.</p><p>The function generates the sequence using the algorithm given by</p><p><em>seq(m+1) = exp(-j·π·<code>R</code>·m·(m+1)/<code>N</code>)</em>, for <em>m = 0, …, <code>N</code>-1</em>.</p><p>The function uses a negative polarity on the argument of the exponent, that is, a clockwise sequence of phases.</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq = zadoffChuSeq(<span class="number">25</span>,<span class="number">139</span>);</span><br><span class="line"><span class="built_in">plot</span>(<span class="built_in">abs</span>(xcorr(seq)./<span class="built_in">length</span>(seq)))</span><br></pre></td></tr></tbody></table></figure><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141511128.png"></p><p><strong>ZC序列的性质：</strong></p><ul><li>恒包络。任意长度的ZC序列的信号的幅值恒定，即功率恒定，因此射频器件无需改变能量。</li><li>理想的周期自相关。</li><li>良好的互相关。ZC序列循环移位N后，原序列只与移位后的序列得良好的相关峰值，其它位置的序列相关峰值为0，除此之外，两个根如果是互质的，生成的序列相关峰值几乎为零。</li><li>傅立叶变换后仍是ZC序列。ZC序列既可以做时序相关检测，也可以做频域相关检测。</li><li>ZC序列峰均比低，由于ZC序列时频域都为ZC序列，且幅值恒定，有利于射频功放信号发挥最大的效率。</li></ul><hr><h2 id="m序列和gold序列的自相关特性"><a href="#m序列和gold序列的自相关特性" class="headerlink" title="m序列和gold序列的自相关特性"></a>m序列和gold序列的自相关特性</h2><p><strong>m序列：</strong></p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%生成个固定小区ID的PSS信号函数</span></span><br><span class="line">ncellid = <span class="number">17</span>;   </span><br><span class="line">ncellid0 = <span class="number">16</span>;</span><br><span class="line"><span class="comment">%生成m序列</span></span><br><span class="line">PSS = nrPSS(ncellid);  </span><br><span class="line">PSS0 = nrPSS(ncellid0);  </span><br><span class="line"><span class="comment">%生成自相关和互相关</span></span><br><span class="line">XPSS=xcorr(PSS);  </span><br><span class="line">XPSS0=xcorr(PSS,PSS0);  </span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">plot</span>(XPSS);  </span><br><span class="line">title(<span class="string">'m序列的自相关特性'</span>);  </span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">plot</span>(XPSS0);  </span><br><span class="line">title(<span class="string">'m序列的互相关特性'</span>); </span><br></pre></td></tr></tbody></table></figure><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141524104.png"></p><p><strong>gold序列：</strong></p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%生成个固定小区ID的SSS信号函数  </span></span><br><span class="line">ncellid = <span class="number">17</span>;   </span><br><span class="line">ncellid0 = <span class="number">16</span>;  </span><br><span class="line"><span class="comment">%生成gold序列</span></span><br><span class="line">SSS = nrSSS(ncellid);  </span><br><span class="line">SSS0 = nrSSS(ncellid0);  </span><br><span class="line">XSSS=xcorr(SSS);  </span><br><span class="line">XSSS0=xcorr(SSS,SSS0);  </span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">plot</span>(XSSS);  </span><br><span class="line">title(<span class="string">'Gold序列的自相关特性'</span>);  </span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);  </span><br><span class="line"><span class="built_in">plot</span>(XSSS0);  </span><br><span class="line">title(<span class="string">'Gold序列的互相关特性'</span>);  </span><br></pre></td></tr></tbody></table></figure><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141527679.png"></p><p>自相关的尖锐性较好，只有与自身对齐时，自相关系数最大。</p><hr><h2 id="5G-NR同步方法仿真测试"><a href="#5G-NR同步方法仿真测试" class="headerlink" title="5G NR同步方法仿真测试"></a>5G NR同步方法仿真测试</h2><p>模拟了一个BPSK调制解调的过程，代码如下（我增加了一些注释和代码）</p><figure class="highlight matlab"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% m_bin用来存储生成的m序列，由于这里模拟了三个m序列，所以m_bin是三行127列的二维矩阵</span></span><br><span class="line">m_bin= <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">127</span>);<span class="comment">% 首先进行初始化，所以是全0序列</span></span><br><span class="line">m_bin(<span class="number">1</span>,:) = mseq([<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]); <span class="comment">% 生成127位m序列</span></span><br><span class="line">m_bin(<span class="number">2</span>,:) = mseq([<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]); <span class="comment">% 生成127位m序列  </span></span><br><span class="line">m_bin(<span class="number">3</span>,:) = mseq([<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]); <span class="comment">% 生成127位m序列 </span></span><br><span class="line">m_data = <span class="number">2</span> * [m_bin(<span class="number">1</span>,:) m_bin(<span class="number">2</span>,:) m_bin(<span class="number">3</span>,:)] <span class="number">-1</span>; <span class="comment">% 转换为±1，把三个m序列拼接在一起发送 </span></span><br><span class="line"><span class="comment">% 可以在前面多加几个0，用来模拟信号延迟</span></span><br><span class="line">m_data = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> m_data m_data]; <span class="comment">% 重复两次发送</span></span><br><span class="line">N=<span class="built_in">length</span>(m_data);<span class="comment">% 计算发送周期的长度   </span></span><br><span class="line">Tc=<span class="number">1e-6</span>;<span class="comment">% 码字周期   </span></span><br><span class="line">f=<span class="number">2e6</span>;<span class="comment">% 载波频率  </span></span><br><span class="line">Fs=<span class="number">20</span>;<span class="comment">% 载波周期点数  </span></span><br><span class="line">N_c = Tc * f * N;<span class="comment">% 基带数据对应载波周期数  </span></span><br><span class="line"><span class="comment">%先采用BPSK对发送的m序列进行调制，并在调制信号上叠加加性高斯白噪声，信噪比设置为为5dB。然后在接收端使用BPSK对信号进行解调，如图所示，可以看到调制后的数据及解调后的数据由于干扰比较大，其实很难在解调后的基带数据上进行逐次比较法确定同步序列。</span></span><br><span class="line"><span class="comment">% BPSK调制；  </span></span><br><span class="line">tx_data= <span class="built_in">zeros</span>(N_c * Fs , <span class="number">1</span>);  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: N  </span><br><span class="line">    bit_idx = <span class="number">1</span> : <span class="number">1</span> : Tc * f * Fs;  </span><br><span class="line">    tx_data((<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">length</span>(bit_idx) + bit_idx) = m_data(<span class="built_in">i</span>) * <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> / Fs * bit_idx);  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line">channel_data = awgn(tx_data,<span class="number">-5</span>, <span class="string">'measured'</span>); <span class="comment">% 增加噪声,5dB</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% BPSK解调过程  </span></span><br><span class="line">rx_data = <span class="built_in">zeros</span>(N,<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:N  </span><br><span class="line">    bit_idx = <span class="number">1</span> : <span class="number">1</span> : Tc * f * Fs ;  </span><br><span class="line">    <span class="comment">% channel_data数据与cos(2f*pi*t)相乘  </span></span><br><span class="line">    rx_data_with_4pift = channel_data((<span class="built_in">i</span><span class="number">-1</span>)*<span class="built_in">length</span>(bit_idx) + bit_idx) .* <span class="built_in">cos</span>(<span class="number">2</span> * <span class="built_in">pi</span> / Fs * bit_idx)';  </span><br><span class="line">    <span class="comment">% 积分过滤出基带分量，积分就相当于去除高频分量，恢复出我们想要的数据</span></span><br><span class="line">    rx_data(<span class="built_in">i</span>) = sum(rx_data_with_4pift);  </span><br><span class="line">    <span class="comment">% 但是积分后的数据并不是±1，所以还需要进行转换，这里将0作为判决点</span></span><br><span class="line">    <span class="keyword">if</span> rx_data(<span class="built_in">i</span>) &gt;= <span class="number">0</span></span><br><span class="line">    rx_data(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> rx_data(<span class="built_in">i</span>) = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行相关函数图绘制</span></span><br><span class="line"><span class="comment">% 每一行代表每一种数据的相关函数，这里仅绘制127个点</span></span><br><span class="line">coef= <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">127</span>);  </span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">127</span>  </span><br><span class="line">     coef(<span class="number">1</span>,<span class="built_in">i</span>) = <span class="built_in">min</span>(<span class="built_in">min</span>(corrcoef(rx_data(<span class="built_in">i</span>:<span class="built_in">i</span>+<span class="number">126</span>), m_bin(<span class="number">1</span>,:) )));  </span><br><span class="line">     coef(<span class="number">2</span>,<span class="built_in">i</span>) = <span class="built_in">min</span>(<span class="built_in">min</span>(corrcoef(rx_data(<span class="built_in">i</span>:<span class="built_in">i</span>+<span class="number">126</span>), m_bin(<span class="number">2</span>,:) )));  </span><br><span class="line">     coef(<span class="number">3</span>,<span class="built_in">i</span>) = <span class="built_in">min</span>(<span class="built_in">min</span>(corrcoef(rx_data(<span class="built_in">i</span>:<span class="built_in">i</span>+<span class="number">126</span>), m_bin(<span class="number">3</span>,:) )));  </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">temp = <span class="number">1</span> : <span class="number">127</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(temp,coef(<span class="number">1</span>,:));</span><br><span class="line">ylim([<span class="number">-0.3</span> <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(temp,coef(<span class="number">2</span>,:));</span><br><span class="line">ylim([<span class="number">-0.3</span> <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(temp,coef(<span class="number">3</span>,:));</span><br><span class="line">ylim([<span class="number">-0.3</span> <span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307141605507.png"></p>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023-07-11 5G NR下行同步</title>
      <link href="/2023/07/11/2023-07-11-5G-NR%E4%B8%8B%E8%A1%8C%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/07/11/2023-07-11-5G-NR%E4%B8%8B%E8%A1%8C%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="仝宇学长安排的任务"><a href="#仝宇学长安排的任务" class="headerlink" title="仝宇学长安排的任务"></a>仝宇学长安排的任务</h3><ul><li>熟悉5g NR下行同步原理</li><li>完成sss及pss：<ul><li>发射端信号产生</li><li>接收端同步</li></ul></li><li>人员分配</li><li>时间安排一个月</li></ul><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>1、从整体了解5G NR物理层实现的功能，进而知道我们现在正在做的内容属于哪一部分。</p><p>2、了解5G NR中为什么要进行下行同步。</p><p>3、了解下行同步过程中需要使用的信号以及信道。</p><p>4、了解发射端信号产生和接收端同步的具体方法及MATLAB代码实现。</p><p>5、安排实验人员，规划实验进程。</p><p>6、列出可能出现的其它问题（比如查阅的资料等，ty学长发的、一些其他教材或网络上查询的其他资料等…）。</p><hr><h3 id="具体内容"><a href="#具体内容" class="headerlink" title="具体内容"></a>具体内容</h3><h4 id="从整体理解5G-NR物理层"><a href="#从整体理解5G-NR物理层" class="headerlink" title="从整体理解5G NR物理层"></a>从整体理解5G NR物理层</h4><h5 id="知乎上的资料"><a href="#知乎上的资料" class="headerlink" title="知乎上的资料"></a>知乎上的资料</h5><ul><li><p><strong>物理层在控制面/用户面协议栈中的位置：</strong>位于最底层。</p></li><li><p><strong>物理层可以实现的功能：</strong></p><p>传输信道的错误检测，并向高层提供指示</p><p>传输信道的FEC编码/解码</p><p>HARQ软合并</p><p>传输信道向物理信道的映射</p><p>物理信道功率加权</p><p>物理信道的调制与解调</p><p>频率与时间同步</p><p>无线特征测量，并向高层提供指示</p><p>MIMO天线处理</p><p>物理射频处理（射频相关范围）</p></li><li><p><strong>5G NR的物理信号和物理信道:</strong></p><p><strong>物理信号</strong></p><p><strong>下行（不止以下所列）</strong></p><p>​CSI-RS：信道状态信息参考信号</p><p>​DM-RS：解调参考信号</p><p>​TRS：时频跟踪参考信号</p><p>​PT-RS:相位噪声跟踪参考信号</p><p>​RRM测量参考信号</p><p>​RLM测量参考信号</p><hr><p><strong>上行（不止以下所列）</strong></p><p>​SRS：探测参考信号</p><p>​DM-RS：解调参考信号</p><p>​PT-RS：相位噪声跟踪参考信号</p><hr><p><strong>参考信号的设计规范</strong></p><p>​1、避免持续发送的周期性信号。所谓持续发送，是指不经系统配置即发送，也无法关闭的信号，例如LTE的CRS。</p><p>​2、物理信号占用的时频资源可灵活配置</p><p>​3、支持大规模波束赋形传输</p><hr><p><strong>物理信道</strong></p><p>解释：对应于一组特定的时/频资源，用于承载高层映射的传输信道。每个传输信道均映射到一个物理信道。</p><p>物理信道包括：</p><ul><li>物理下行共享信道（PDSCH）</li><li>物理广播信道（PBCH）</li><li>物理下行控制信道（PDCCH）</li><li>物理上行共享信道（PUSCH）</li><li>物理上行控制信道（PUCCH）</li><li>物理随机接入信道（PRACH）</li></ul><p>con：控制信道传输信令（控制信息），共享信道传输数据（数据信息）</p><hr></li><li><p><strong>每个物理信道详细功能</strong></p></li></ul><p><strong>（1）初始接入信道</strong></p><p><strong>主要完成的事情：</strong>UE开机/移动到新的小区覆盖范围之后（也就是相当于要接入），需要通过下行同步信道获得与网络的下行同步。</p><p><strong>需要同步的东西：</strong>时间、频率、小区的物理小区标识、小区的广播信息 ==&gt; 获取小区的系统信息以确定后续操作（驻留、小区重选、发起随机接入等）。</p><p><strong>出现的问题：</strong>频率升高后，网络覆盖变小。</p><p><strong>解决方法：</strong>通过大规模天线的波束赋形增益，业务信道的覆盖范围得以普遍提升。 NR采用波束扫描技术提升下行同步信道的覆盖范围。</p><p><strong>如何进行波束扫描：</strong>以SSB为单位，SSB中包含PSS、SSS、PBCH</p><p>下图是波束扫描方案：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307112302305.png" alt="SSB 波束扫描"></p><ul><li><p>一个扫描周期内的SSB构成一个SSB突发集，扫描周期是SSB突发集的发送周期。</p></li><li><p>一个突发集内， 不同编号的SSB可以用不同方向的波束发送，形成<strong>扫描波束</strong>。</p></li><li><p>SSB突发集以一定的周期进行重复发送，不同发送周期内有相同索引的SSB所采用的波束方向相同。</p></li></ul><p><strong>SSB个数的决定因素</strong>：系统开销和覆盖的要求</p><ul><li>个数越多就可以用更多更窄的波束发送SSB ===&gt; 可以获得更大的波束赋形增益和覆盖效果，系统开销也会增加。</li><li>频点升高 -&gt; SSB覆盖的需求增强 -&gt; 允许的SSB数目增大。</li><li>实际网络中可以根据系统频点、用户分布等因素选择实际发送的SSB个数和波束方向。</li></ul><p><strong>（2）上下行控制信道</strong></p><p>定义：需要相关的下行控制信令辅助：上下行传输资源分配信息、传输块大小、调制等级和天行端口等。</p><p>控制信令在PDCCH上传输，设计要求：</p><ul><li>灵活的资源配置：支持小区间干扰协调。</li><li>支持低时延业务：一个时隙内允许有多个PDCCH发送机会（允许在一个时隙内多个符号位置上发送PDCCH）。</li><li>大规模天线传输：应发挥大规模天线技术的优势，目的是为了达到/超过业务信道的覆盖范围。</li></ul><p><strong>（3）上下行业务信道</strong></p><p><strong>下行：</strong>下行共享信道（DL-SCH)是下行数据的主要传输信道，映射到PDSCH上进行传输。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307121002035.png" alt="PDSCH传输的处理过程"></p><p><strong>上行：</strong>上行共享信道（UL-SCH）是上行数据的主要传输信道，映射到PUSCH上进行传输。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307121003559.png" alt="PUSCH传输的处理过程"></p><p><strong>DM-RS的使用：</strong>NR的PDSCH和PUSCH均以DM-RS为解调导频，DM-RS和数据的预编码相同，因此基于DM-RS估计出的信道可以直接用于数据的解调；采用了DM-RS前置设计，DM-RS尽量靠近调度资源的时域起始位置 ==&gt; 降低终端解调、解码的时延。</p><p><strong>PT-RS的使用：</strong>用于相位噪声的跟踪和补偿，主要用于高频段，因为高频段的相位噪声更加明显。</p><p><strong>BWP的使用：</strong>一个UE最多可以配置4个BWP，这取决于UE的能力，传输数据可以在4个BWP之间进行切换，通过DCI信令指示或者高层信令进行切换。</p><hr><h5 id="《5G-NR物理层技术详解原理、模型和组件》中的内容"><a href="#《5G-NR物理层技术详解原理、模型和组件》中的内容" class="headerlink" title="《5G NR物理层技术详解原理、模型和组件》中的内容"></a>《5G NR物理层技术详解原理、模型和组件》中的内容</h5><p>以下内容仅围绕物理层概述内容书写：</p><hr><h6 id="无线协议架构"><a href="#无线协议架构" class="headerlink" title="无线协议架构"></a>无线协议架构</h6><p>无线协议架构分类：控制平面架构和用户平面架构。</p><p>​<strong>用户面：</strong>递交用户数据</p><p>​<strong>控制面：</strong>连接建立、移动性和安全</p><p>[其他内容在大唐杯中也介绍过，而且不是物理层的重点，因此在文档里不再赘述]</p><hr><h6 id="NR物理层：关键技术"><a href="#NR物理层：关键技术" class="headerlink" title="NR物理层：关键技术"></a>NR物理层：关键技术</h6><p><strong>（1）调制</strong></p><p>上行和下行都支持正交相移键控（QPSK）、16阶正交幅度调制（QAM）、64QAM和256QAM调制方式。【这些内容都可以参考通信原理I教材或者网络上的杨老师的学堂在线进行学习】</p><p>上行还支持π/2-BPSK进一步降低均峰比。</p><p><strong>（2）波形</strong></p><p>NR上行和下行都采用了循环前缀OFDM，循环前缀的作用是为了满足正交性。</p><p>NR具有可扩展的OFDM参数集来满足在宽广的频率范围内的多种服务需求，可以通过下表了解下可扩展的OFDM参数集</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307121039410.png" alt="可扩展的OFDM参数集"></p><hr><p><strong>OFDM可以参考王老师的PPT：</strong></p><p>何为OFDM调制：在等间隔的载波上并行调制信号，假设间隔为△f</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307121948092.png" alt="OFDM"></p><ul><li>OFDM调制原理：虽然相邻的子载波有交叠的地方，但是每个子载波频域幅度的峰值与其他子载波的零值是重合的。【在每个子载波的中心频点上采样时，其他子载波的值为0，具有正交性】</li><li>正交性避免了子载波的相互干扰，重叠性则降低了子载波的间隔，提高了频谱效率。</li></ul><p><strong>下面是调制和解调框图：</strong></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307121951972.png" alt="调制"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307121951721.png" alt="解调"></p><hr><p><strong>CP-OFDM关键参数——载波间隔和CP长度</strong></p><p><strong>终端移动造成的多普勒频移：</strong></p><ul><li>多径信道中，不同径的多普勒频移不同，形成多普勒频移。若多普勒频移大于子载波间隔△f，会造成子载波间干扰。</li><li>在OFDM系统中，子载波间隔△f要大于最大多普勒频移fDmax，以降低多普勒扩展造成的ICI。</li></ul><p><strong>多径传播造成的残余ISI：</strong></p><ul><li>在接收端，一个OFDM符号开头或结尾可能与另一条路径来的另一个OFDM符号的一小部分发生重叠，产生残余ISI。【这也就是我们要使用循环前缀CP的原因】</li></ul><p><strong>两个关键参数：</strong>子载波间隔△f和CP长度Tcp，需要兼顾：</p><ul><li>子载波间隔△f需要足够大，以对抗多普勒频移扩展和频偏造成的CSI</li><li>CP长度△f也要足够大，用来对抗多径传播产生的ISI</li><li>CP并不承载有用信息，发射CP是浪费时间和功率资源的，为降低CP的开销，在增大CP的同时需要增大符号长度T</li></ul><hr><p><strong>多天线：</strong></p><p>低频段，LTE后期版本中多天线技术主要用于功能增强。</p><p>高频段，不仅仅是获得很高的频谱效率，主要的挑战是覆盖。【高频路径损耗较大】</p><hr><h4 id="5G-NR需要进行下行同步的原因"><a href="#5G-NR需要进行下行同步的原因" class="headerlink" title="5G NR需要进行下行同步的原因"></a>5G NR需要进行下行同步的原因</h4><ul><li>UE和基站保持时间和频率的同步是两者相互传输数据的<strong>前提</strong>。</li><li>UE通过检测基站发送的同步信号来完成时间和频率的同步。</li></ul><p><strong>定义：</strong>指终端通过基站周期性的、在特定位置发送的二进制同步序号序列与基站进行帧率、相位与10ms的同步以及小区同步。</p><p><strong>目的：</strong>UE可解调出小区广播的主信息块MIB和系统信息快SIB，因此同步是终端与基站建立通信的<strong>起点</strong>。</p><p><u><em>下面介绍MIB 和 SIB 是什么</em></u>：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307122025440.png" alt="MIB ＆ SIB"></p><p><strong>下行同步的原因如下（四点）：</strong></p><ul><li>1、终端需要搜索到小区的高频载波的中心频点，并与在载波信号进行模拟信号的频率同步，因为只有频率相同，收发信号的双方的步调才能一致。</li><li>2、终端要获得小区的<strong>带宽</strong>，获取小区的带宽后终端可以知道小区<strong>有多少可以用于传输数据的子载波</strong>。</li><li>3、终端要与小区的10ms帧进行比特率同步、比特相位同步和10ms帧同步，因为10ms帧结构的二进制比特数据，当终端刚开机时，接收基站发送的结构化的二进制比特数据并不知道接收数据开始的位置在10ms帧的具体位置。</li><li>4、终端要能够获取小区的信息，当终端获取小区的多种信息，如PCID，终端和基站安才可以正常的发送数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5G物理层大唐杯笔记</title>
      <link href="/2023/07/10/5G%E7%89%A9%E7%90%86%E5%A4%A7%E5%94%90%E6%9D%AF%E7%AC%94%E8%AE%B0%E5%B1%82/"/>
      <url>/2023/07/10/5G%E7%89%A9%E7%90%86%E5%A4%A7%E5%94%90%E6%9D%AF%E7%AC%94%E8%AE%B0%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="1、物理层概述"><a href="#1、物理层概述" class="headerlink" title="1、物理层概述"></a>1、物理层概述</h3><p><strong>物理层的位置</strong>：最底层</p><p>RRC：终端和基站之间信令交互的实体，用户面是不需要信令交互的</p><p>​信令相关数据，基站和终端之间信令面通了，就可以发信令之间的数据了</p><p>NAS：非接入层，终端——AMF</p><p>PDCD：加密和完整性保护</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307102201054.png" alt="控制面协议栈"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307102203605.png" alt="用户面协议栈"></p><h4 id="物理层的主要功能"><a href="#物理层的主要功能" class="headerlink" title="物理层的主要功能"></a>物理层的主要功能</h4><ul><li>传输信道的错误检测，并向高层提供指示</li><li>传输信道的FEC编码/解码</li><li>HARQ软合并</li><li>传输信道向物理信道的映射</li><li>物理信道功率加权</li><li>物理信道的调制与解调</li><li>频率与时间同步</li><li>无线特征测量，并向高层提供指示</li><li>MIMO天线处理</li><li>物理射频处理（射频相关范围）</li></ul><h4 id="物理资源"><a href="#物理资源" class="headerlink" title="物理资源"></a>物理资源</h4><ul><li><p>NR基本时间单位：Tc</p><p>Tc = 1/(△fmax*Nf)</p><p>△fmax = 480 * 10^3</p><p>Nf = 4096</p><p><strong>==&gt;</strong> Tc =5.0862 * 10^-10 s</p></li><li><p>无线帧：10ms</p></li><li><p>子帧：1ms</p></li><li><p>时隙：μ越大，一个子帧中时隙就越多</p></li><li><p>OFDM符号：一个时隙是14个符号，时隙数越多，符号数越多，符号长度越短</p></li><li><p>天线端口：用于区分资源在空间上的差别</p></li><li><p>子载波</p></li></ul><h4 id="天线端口"><a href="#天线端口" class="headerlink" title="天线端口"></a>天线端口</h4><p>进行信道估计和分辨的端口数，每一个天线端口对应一个物理资源单元。</p><p>属于逻辑端口，与物理信道/信号之间存在着严格的对应关系</p><p>即一个端口对于接收者来说，就是一个独立的逻辑过程，这个过程就是接收机可以利用参考信号的物理资源单元的特性进行信道估计，并进一步地实现对接收信号的解调。</p><h4 id="5G信道和信号"><a href="#5G信道和信号" class="headerlink" title="5G信道和信号"></a>5G信道和信号</h4><p>从上到下可以这样分SDAP-&gt;PDCP-&gt;RLC-&gt;MAC-&gt;PHY</p><p><strong>5GNR协议实体：</strong></p><ul><li>SDAP：服务数据适应协议</li><li>PDCP：分组数据汇聚协议</li><li>RLC：无线链路控制</li><li>MAC：介质访问控制</li><li>PHY：物理层</li></ul><p><strong>信道的分为：</strong></p><ul><li>逻辑信道：MAC层和RLC子层之间的信道</li><li>传输信道：物理层与MAC层之间的信道</li><li>物理信道：物理层实际传输信息的信道</li></ul><h4 id="5G信道映射关系"><a href="#5G信道映射关系" class="headerlink" title="5G信道映射关系"></a>5G信道映射关系</h4><p><strong>1、SSB：PSS + SSS + PBCH</strong></p><p>物理层 到 MAC层需要通过BCH（广播）映射，再通过BCCH逻辑信道向上映射到RLC层。</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111401608.png" alt="信道映射关系"></p><center><b>信道映射关系<b></b></b></center><h4 id="5G-NR-网络中的逻辑信道"><a href="#5G-NR-网络中的逻辑信道" class="headerlink" title="5G(NR)网络中的逻辑信道"></a>5G(NR)网络中的逻辑信道</h4><p>定义：MAC子层和RLC子层之间的信道</p><p>【只关注传输的信息是什么，根据传输的是控制信息还是业务信息，逻辑信道分为：控制信道和业务信道】</p><table><thead><tr><th align="left">控制信道</th></tr></thead><tbody><tr><td align="left">BCCH：广播系统信息</td></tr><tr><td align="left">PCCH：用来寻呼终端的信道</td></tr><tr><td align="left">CCCH：用于在UE和网络之间还没有建立RRC连接时，发送控制信息</td></tr><tr><td align="left">DCCH：RRC建立之后，UE和网络之间发送一对一的专用控制信息</td></tr><tr><td align="left"><strong>业务信道：</strong></td></tr><tr><td align="left">DTCH：专用于一个UE的点对点用户传输的信道，上下行链路中都有</td></tr></tbody></table><h4 id="5G-NR）网络中的传输信道"><a href="#5G-NR）网络中的传输信道" class="headerlink" title="5G(NR）网络中的传输信道"></a>5G(NR）网络中的传输信道</h4><table><thead><tr><th>下行</th></tr></thead><tbody><tr><td>广播信道BCH：通过广播的方式传输下行控制信息</td></tr><tr><td>下行共享信道DL-SCH：用于传输下行控制或者用户信息</td></tr><tr><td>寻呼信道：PCH：用于传输寻呼信息</td></tr><tr><td><strong>上行</strong></td></tr><tr><td>上行共享信道UL-SCH：传输上行控制或者用户信息</td></tr><tr><td>随机接入信道RACH：用于传输随机接入前导码</td></tr></tbody></table><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111415998.png" alt="信道示意图"></p><h4 id="5G物理信道与信号概述"><a href="#5G物理信道与信号概述" class="headerlink" title="5G物理信道与信号概述"></a>5G物理信道与信号概述</h4><p>了解下行与上行的概念</p><ul><li><strong>Downlink</strong><ul><li>Physical Channel<ul><li>PBCH</li><li>PDCCH</li><li>PDSCH</li></ul></li><li>Physical Signals<ul><li>PSS/SSS</li><li>DM-RS</li><li>CSI-RS： 下行信道质量指示参考信号</li><li>PT-RS</li></ul></li></ul></li><li><strong>Uplink</strong><ul><li>Physical Channel<ul><li>PRACH：随机接入信道</li><li>PUCCH</li><li>PUSCH</li></ul></li><li>Physical Signals<ul><li>DM_RS：解调参考信号</li><li>PT-RS： 相位跟踪参考信号</li><li>SRS： 信道探测参考信号</li></ul></li></ul></li></ul><h3 id="2、小区搜索"><a href="#2、小区搜索" class="headerlink" title="2、小区搜索"></a>2、小区搜索</h3><h4 id="搜索流程"><a href="#搜索流程" class="headerlink" title="搜索流程"></a>搜索流程</h4><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111435884.png" alt="搜索流程"></p><p> 其中SSS -&gt; PBCH中需要DMRS信号</p><h4 id="小区搜索-SSB"><a href="#小区搜索-SSB" class="headerlink" title="小区搜索-SSB"></a>小区搜索-SSB</h4><p><strong>定义：</strong>5GNR中，主同步信号（PSS）、辅同步信号（SSS）和PBCH共同构成一个SSB（SS/PBCH BLOCK）</p><p><strong>占用情况：</strong>时域上4个OFDM，频域占用240个子载波（20个PRB）</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111521900.png" alt="时域"></p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111522470.png" alt="子载波映关系"></p><h4 id="小区搜索-SSB（频域位置）"><a href="#小区搜索-SSB（频域位置）" class="headerlink" title="小区搜索-SSB（频域位置）"></a>小区搜索-SSB（频域位置）</h4><p><strong>说明：</strong>SS block频域位置用SSREF（KHz）表示，对应的索引用GSCN（无量纲）来表示：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111612935.png" alt="小区搜索表"></p><ul><li>引入了同步Raster，SS/PBCH Block按照同步Raster进行布局，区别于Channel Raster</li><li>对于不同频段，SSB块支持的子载波间隔（15KHz、30KHz、120KHz、240KHz）、pattern不同（caseA、caseB、caseC、caseD、caseE）</li></ul><p>频域上，NR中SSB可以传输在载波的任何位置，SSB位置服从synchronization Raster；PDCCH/PDSCH载波中心服从Channel Raster，SSB的子载波位置0可以不与物理资源块RB对齐。</p><p>SSB 子载波0与CRB0的偏移 = offsetToPointA（单位：RB） + KSSB<strong>（单位：子载波）</strong></p><ul><li>KSSB，子载波偏移：低4个bits来源于MIB，最高位（5bit）来自于PBCH编码中的</li><li>OffsetToPointA：来源于SIB1</li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111646480.png" alt="子载波偏移"></p><h4 id="小区搜索-获取PCI"><a href="#小区搜索-获取PCI" class="headerlink" title="小区搜索-获取PCI"></a>小区搜索-获取PCI</h4><ul><li>检PSS<ul><li>PSS为3条长度127的伪随机序列，采用BPSK M序列</li><li>中间连续的127个子载波，加上两侧8/9个SC保护间隔，共占144个子载波</li><li>UE搜索到PSS后，可以获取PCI中的NID(2) ∈ {0,1,2}</li></ul></li><li>检SSS<ul><li>SSS为336条的长度127的伪随机序列，采用BPSK M序列</li><li>中间连续的127个子载波，加上两侧8/9个SC作为保护间隔，共占144个子载波</li><li>UE搜索到SSS后，可以获取PCI中的NID(1) 属于 {0,1,….,335}</li></ul></li></ul><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111646552.png" alt="PCI1"></p><p><strong>备注</strong>：UE检测出PSS，就知道SSB的GSCN和同步参考频率SSREF</p><h4 id="小区搜索-DM-RS-for-PBCH"><a href="#小区搜索-DM-RS-for-PBCH" class="headerlink" title="小区搜索-DM-RS for PBCH"></a>小区搜索-DM-RS for PBCH</h4><p>PBCH的DM-RS在时域上占用和PBCH相同的符号数，在频域上间隔4个子载波，初始偏移由PCI确定：</p><p>可以对照这上满那个DM-RS索引位置表进行确定，可以通过表达式确定v的值即 v = NcellID mod4</p><p>需要注意的是需要置零的位置不是DM-RS的索引位置，视频中的例子如下图所示：</p><p><img src="https://picture-cloud-storage-pyp.oss-cn-beijing.aliyuncs.com/img/202307111703655.png" alt="PCI2"></p>]]></content>
      
      
      <categories>
          
          <category> 5G </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>裴同学的第一篇博客</title>
      <link href="/2023/07/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/07/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>感觉使用微信公众号或者CSDN什么的发表一些东西比较不灵活，而且想记录一些自己的生活或者发表一些平时所学文章什么的，因此想搭建一个属于自己的网站使用。</p><p>本网站使用github + hexo + 阿里云域名成功搭建，并可以通过输入域名的方式直接在互联网中访问。</p><p>在此我恭喜我自己^-^！</p><p><img src="https://img1.baidu.com/it/u=2305450569,1175342556&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPEG&amp;fmt=auto?sec=1689008400&amp;t=0149e6fb88a49415f32a8c81e862f0ce"></p><p>后续还会对网站进行美化以及内部结构的优化，平时也会不定期发一些什么东西。</p><p>然后呢，现在这个域名是<a href="http://testepyp.top,是大三下学期计算机网络课程设计所使用到的一个域名,等到期了之后再换一个吧,这个起的有点随便./">http://testepyp.top，是大三下学期计算机网络课程设计所使用到的一个域名，等到期了之后再换一个吧，这个起的有点随便。</a></p><p>问了不占用过大的本地空间，本网站使用了阿里云对象存储OSS，同时下载了PicGo软件创建图层进行图片上传，十分方便。</p><p>后期有时间会将其他地方的博文进行搬运！！！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
